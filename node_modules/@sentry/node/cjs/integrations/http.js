Object.defineProperty(exports, '__esModule', { value: true });

var core = require('@sentry/core');
var utils = require('@sentry/utils');
var http = require('./utils/http.js');

var NODE_VERSION = utils.parseSemver(process.versions.node);

/** http module integration */
class Http  {
  /**
   * @inheritDoc
   */
   static __initStatic() {this.id = 'Http';}

  /**
   * @inheritDoc
   */
   __init() {this.name = Http.id;}

  /**
   * @inheritDoc
   */
  

  /**
   * @inheritDoc
   */
  

  /**
   * @inheritDoc
   */
   constructor(options = {}) {;Http.prototype.__init.call(this);
    this._breadcrumbs = typeof options.breadcrumbs === 'undefined' ? true : options.breadcrumbs;
    this._tracing = typeof options.tracing === 'undefined' ? false : options.tracing;
  }

  /**
   * @inheritDoc
   */
   setupOnce() {
    // No need to instrument if we don't want to track anything
    if (!this._breadcrumbs && !this._tracing) {
      return;
    }

    var wrappedHandlerMaker = _createWrappedRequestMethodFactory(this._breadcrumbs, this._tracing);

        var httpModule = require('http');
    utils.fill(httpModule, 'get', wrappedHandlerMaker);
    utils.fill(httpModule, 'request', wrappedHandlerMaker);

    // NOTE: Prior to Node 9, `https` used internals of `http` module, thus we don't patch it.
    // If we do, we'd get double breadcrumbs and double spans for `https` calls.
    // It has been changed in Node 9, so for all versions equal and above, we patch `https` separately.
    if (NODE_VERSION.major && NODE_VERSION.major > 8) {
            var httpsModule = require('https');
      utils.fill(httpsModule, 'get', wrappedHandlerMaker);
      utils.fill(httpsModule, 'request', wrappedHandlerMaker);
    }
  }
} Http.__initStatic();

// for ease of reading below

/**
 * Function which creates a function which creates wrapped versions of internal `request` and `get` calls within `http`
 * and `https` modules. (NB: Not a typo - this is a creator^2!)
 *
 * @param breadcrumbsEnabled Whether or not to record outgoing requests as breadcrumbs
 * @param tracingEnabled Whether or not to record outgoing requests as tracing spans
 *
 * @returns A function which accepts the exiting handler and returns a wrapped handler
 */
function _createWrappedRequestMethodFactory(
  breadcrumbsEnabled,
  tracingEnabled,
) {
  return function wrappedRequestMethodFactory(originalRequestMethod) {
    return function wrappedMethod( ...args) {
            var httpModule = this;

      var requestArgs = http.normalizeRequestArgs(this, args);
      var requestOptions = requestArgs[0];
      var requestUrl = http.extractUrl(requestOptions);

      // we don't want to record requests to Sentry as either breadcrumbs or spans, so just use the original method
      if (http.isSentryRequest(requestUrl)) {
        return originalRequestMethod.apply(httpModule, requestArgs);
      }

      let span;
      let parentSpan;

      var scope = core.getCurrentHub().getScope();
      if (scope && tracingEnabled) {
        parentSpan = scope.getSpan();
        if (parentSpan) {
          span = parentSpan.startChild({
            description: `${requestOptions.method || 'GET'} ${requestUrl}`,
            op: 'http.client',
          });

          var sentryTraceHeader = span.toTraceparent();
          (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&
            utils.logger.log(
              `[Tracing] Adding sentry-trace header ${sentryTraceHeader} to outgoing request to ${requestUrl}: `,
            );

          var headerBaggageString = requestOptions.headers && (requestOptions.headers.baggage );

          requestOptions.headers = {
            ...requestOptions.headers,
            'sentry-trace': sentryTraceHeader,
            baggage: utils.mergeAndSerializeBaggage(span.getBaggage(), headerBaggageString),
          };
        }
      }

            return originalRequestMethod
        .apply(httpModule, requestArgs)
        .once('response', function ( res) {
                    var req = this;
          if (breadcrumbsEnabled) {
            addRequestBreadcrumb('response', requestUrl, req, res);
          }
          if (tracingEnabled && span) {
            if (res.statusCode) {
              span.setHttpStatus(res.statusCode);
            }
            span.description = http.cleanSpanDescription(span.description, requestOptions, req);
            span.finish();
          }
        })
        .once('error', function () {
                    var req = this;

          if (breadcrumbsEnabled) {
            addRequestBreadcrumb('error', requestUrl, req);
          }
          if (tracingEnabled && span) {
            span.setHttpStatus(500);
            span.description = http.cleanSpanDescription(span.description, requestOptions, req);
            span.finish();
          }
        });
    };
  };
}

/**
 * Captures Breadcrumb based on provided request/response pair
 */
function addRequestBreadcrumb(event, url, req, res) {
  if (!core.getCurrentHub().getIntegration(Http)) {
    return;
  }

  core.getCurrentHub().addBreadcrumb(
    {
      category: 'http',
      data: {
        method: req.method,
        status_code: res && res.statusCode,
        url,
      },
      type: 'http',
    },
    {
      event,
      request: req,
      response: res,
    },
  );
}

exports.Http = Http;
//# sourceMappingURL=http.js.map
