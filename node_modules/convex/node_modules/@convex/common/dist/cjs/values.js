"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.convexToJson = exports.jsonToConvex = exports.Id = void 0;
const Base64 = __importStar(require("base64-js"));
const long_1 = __importDefault(require("long"));
const LITTLE_ENDIAN = true;
const MIN_INT64 = BigInt("-9223372036854775808");
const MAX_INT64 = BigInt("9223372036854775807");
/**
 * An identifier for a document in Convex.
 *
 * Convex documents are uniquely identified by their `Id`, which is accessible
 * on the `_id` field. To learn more, see [Data Modeling](https://docs.convex.dev/using/data-modeling).
 *
 * Documents can be loaded using `db.get(id)` in query and mutation functions.
 *
 * **Important**: Use `myId.equals(otherId)` to check for equality.
 * Using `===` will not work because two different instances of `Id` can refer
 * to the same document.
 *
 * @public
 */
class Id {
    constructor(encoded) {
        this.encoded = encoded;
    }
    /**
     * Check if this {@link Id} refers to the same document as another {@link Id}.
     *
     * @param other - The other {@link Id} to compare to.
     * @returns `true` if the objects refer to the same document.
     */
    equals(other) {
        if (other) {
            return this.toString() == other.toString();
        }
        return false;
    }
    /**
     * Parse an {@link Id} from its JSON representation.
     */
    static fromJSON(obj) {
        if (typeof obj.$id !== "string") {
            throw new Error(`Object ${JSON.stringify(obj)} isn't a valid Id`);
        }
        return new Id(obj.$id);
    }
    /**
     * Convert an {@link Id} into its JSON representation.
     */
    toJSON() {
        return { $id: this.encoded };
    }
    /**
     * Parse an {@link Id} from its string representation.
     */
    static fromString(s) {
        return new Id(s);
    }
    /**
     * Convert an {@link Id} into its string representation.
     */
    toString() {
        return this.encoded;
    }
}
exports.Id = Id;
function isSpecial(n) {
    return Number.isNaN(n) || !Number.isFinite(n) || Object.is(n, -0);
}
function bigIntToBase64(value) {
    const integerBytes = long_1.default.fromString(value.toString(), false).toBytesLE();
    return Base64.fromByteArray(new Uint8Array(integerBytes));
}
function base64ToBigInt(encoded) {
    const integerBytes = Base64.toByteArray(encoded);
    if (integerBytes.byteLength !== 8) {
        throw new Error(`Received ${integerBytes.byteLength} bytes, expected 8 for $integer`);
    }
    return BigInt(long_1.default.fromBytesLE(Array.from(integerBytes), false).toString());
}
const MAX_IDENTIFIER_LEN = 64;
const ALL_UNDERSCORES = /^_+$/;
const IDENTIFIER_REGEX = /^[a-zA-Z_][a-zA-Z0-9_]{0,63}$/;
function validateObjectField(k) {
    if (k.length === 0) {
        throw new Error("Empty field names are disallowed.");
    }
    if (k.length > MAX_IDENTIFIER_LEN) {
        throw new Error(`Field name ${k} exceeds maximum field name length ${MAX_IDENTIFIER_LEN}.`);
    }
    if (k.startsWith("$")) {
        throw new Error(`Field name ${k} starts with a '$', which is reserved.`);
    }
    if (ALL_UNDERSCORES.test(k)) {
        throw new Error(`Field name ${k} can't exclusively be underscores.`);
    }
    if (!IDENTIFIER_REGEX.test(k)) {
        throw new Error(`Field name ${k} must only contain alphanumeric characters or underscores and can't start with a number.`);
    }
}
function jsonToConvexInternal(value) {
    if (value === null) {
        return value;
    }
    if (typeof value === "boolean") {
        return value;
    }
    if (typeof value === "number") {
        return value;
    }
    if (typeof value === "string") {
        return value;
    }
    if (value instanceof Array) {
        return value.map(jsonToConvexInternal);
    }
    if (typeof value !== "object") {
        throw new Error(`Unexpected type of ${value}`);
    }
    const entries = Object.entries(value);
    if (entries.length === 1) {
        const key = entries[0][0];
        if (key === "$id" || key === "$weakRef" || key === "$strongRef") {
            return Id.fromJSON(value);
        }
        if (key === "$bytes") {
            if (typeof value.$bytes !== "string") {
                throw new Error(`Malformed $bytes field on ${value}`);
            }
            return Base64.toByteArray(value.$bytes).buffer;
        }
        if (key === "$integer") {
            if (typeof value.$integer !== "string") {
                throw new Error(`Malformed $integer field on ${value}`);
            }
            return base64ToBigInt(value.$integer);
        }
        if (key === "$float") {
            if (typeof value.$float !== "string") {
                throw new Error(`Malformed $float field on ${value}`);
            }
            const floatBytes = Base64.toByteArray(value.$float);
            if (floatBytes.byteLength !== 8) {
                throw new Error(`Received ${floatBytes.byteLength} bytes, expected 8 for $float`);
            }
            const floatBytesView = new DataView(floatBytes.buffer);
            const float = floatBytesView.getFloat64(0, LITTLE_ENDIAN);
            if (!isSpecial(float)) {
                throw new Error(`Float ${float} should be encoded as a number`);
            }
            return float;
        }
        if (key === "$set") {
            if (!(value.$set instanceof Array)) {
                throw new Error(`Malformed $set field on ${value}`);
            }
            return new Set(value.$set.map(jsonToConvexInternal));
        }
        if (key === "$map") {
            if (!(value.$map instanceof Array)) {
                throw new Error(`Malformed $map field on ${value}`);
            }
            const map = new Map();
            for (const pair of value.$map) {
                if (!(pair instanceof Array) || pair.length !== 2) {
                    throw new Error(`Malformed pair in $map ${value}`);
                }
                const k = jsonToConvexInternal(pair[0]);
                const v = jsonToConvexInternal(pair[1]);
                map.set(k, v);
            }
            return map;
        }
    }
    const out = {};
    for (const [k, v] of Object.entries(value)) {
        validateObjectField(k);
        out[k] = jsonToConvexInternal(v);
    }
    return out;
}
/**
 * Parse a Convex value from its JSON representation.
 *
 * This function will revive classes like {@link Id} that have been serialized to JSON, parse out `BigInt`s, and so on.
 *
 * To learn more about Convex values, see [Types](https://docs.convex.dev/using/types).
 *
 * @param value - The JSON representation of a Convex value previously created with {@link convexToJson}.
 * @returns The JavaScript representation of the Convex value.
 *
 * @public
 */
function jsonToConvex(value) {
    return jsonToConvexInternal(value);
}
exports.jsonToConvex = jsonToConvex;
function convexToJsonInternal(value, originalValue, context) {
    if (value === undefined) {
        throw new Error(`undefined is not a valid Convex value (present at path ${context} in original object ${JSON.stringify(originalValue)}). To learn about Convex's supported types, see https://docs.convex.dev/using/types.`);
    }
    if (value === null) {
        return value;
    }
    if (value instanceof Id) {
        return value.toJSON();
    }
    if (typeof value === "bigint") {
        if (value < MIN_INT64 || MAX_INT64 < value) {
            throw new Error(`BigInt ${value} does not fit into a 64-bit signed integer.`);
        }
        return { $integer: bigIntToBase64(value) };
    }
    if (typeof value === "number") {
        if (isSpecial(value)) {
            const buffer = new ArrayBuffer(8);
            new DataView(buffer).setFloat64(0, value, LITTLE_ENDIAN);
            return { $float: Base64.fromByteArray(new Uint8Array(buffer)) };
        }
        else {
            return value;
        }
    }
    if (typeof value === "boolean") {
        return value;
    }
    if (typeof value === "string") {
        return value;
    }
    if (value instanceof ArrayBuffer) {
        return { $bytes: Base64.fromByteArray(new Uint8Array(value)) };
    }
    if (value instanceof Array) {
        return value.map((value, i) => convexToJsonInternal(value, originalValue, context + `[${i}]`));
    }
    if (value instanceof Set) {
        return {
            $set: [...value].map((value, i) => convexToJsonInternal(value, originalValue, context + `.keys()[${i}]`)),
        };
    }
    if (value instanceof Map) {
        return {
            $map: [...value].map(([k, v], i) => {
                const jsonKey = convexToJsonInternal(k, originalValue, context + `.keys()[${i}]`);
                const jsonValue = convexToJsonInternal(v, originalValue, context + `.values()[${i}]`);
                return [jsonKey, jsonValue];
            }),
        };
    }
    if (typeof value !== "object") {
        throw new Error(`${value} is not a supported Convex type (present at path ${context} in original object ${JSON.stringify(originalValue)}). To learn about Convex's supported types, see https://docs.convex.dev/using/types.`);
    }
    const prototype = Object.getPrototypeOf(value);
    if (prototype !== null && prototype !== Object.prototype) {
        throw new Error(`${value} is not a supported Convex type (present at path ${context} in original object ${JSON.stringify(originalValue)}). To learn about Convex's supported types, see https://docs.convex.dev/using/types.`);
    }
    const out = {};
    for (const [k, v] of Object.entries(value)) {
        validateObjectField(k);
        out[k] = convexToJsonInternal(v, originalValue, context + `.${k}`);
    }
    return out;
}
/**
 * Convert a Convex value to its JSON representation.
 *
 * Use {@link jsonToConvex} to recreate the original value.
 *
 * To learn more about Convex values, see [Types](https://docs.convex.dev/using/types).
 *
 * @param value - A Convex value to convert into JSON.
 * @returns The JSON representation of `value`.
 *
 * @public
 */
function convexToJson(value) {
    return convexToJsonInternal(value, value, "");
}
exports.convexToJson = convexToJson;
//# sourceMappingURL=values.js.map