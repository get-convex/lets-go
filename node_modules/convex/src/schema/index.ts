/* eslint-disable @typescript-eslint/no-unused-vars */
/**
 * Utilities for defining the schema of your Convex project.
 *
 * ## Usage
 *
 * Schemas should be placed in a `schema.ts` file in your `convex/` directory.
 *
 * Schema definitions should be built using {@link defineSchema},
 * {@link defineTable}, and {@link s}. Make sure to export the schema as the
 * default export.
 *
 * ```ts
 * import { defineSchema, defineTable, s } from "convex/schema";
 *
 *  export default defineSchema({
 *    messages: defineTable({
 *      body: s.string(),
 *      time: s.number(),
 *      user: s.id(),
 *    }),
 *    users: defineTable({
 *      name: s.string(),
 *    }),
 *  });
 * ```
 *
 * To learn more about schemas, see [Defining a Schema](https://docs.convex.dev/using/schemas).
 * @module
 */
import { Id } from "@convex-dev/common";
import { GenericDocument, GenericTableIndexes } from "../server/data_model.js";

/**
 * A Convex type defined in a schema.
 *
 * These should be constructed using {@link s}.
 *
 * This type encapsulates both:
 * - The TypeScript type that represents this Convex type.
 * - The set of index field paths that can be used to build indexes on this type.
 * @public
 */
export type SchemaType<TypeScriptType, FieldPaths extends string> = {
  type: TypeScriptType;
  fieldPaths: FieldPaths;

  // Property for a bit of nominal type safety.
  _isSchemaType: undefined;
};

// Placeholder for a schema type because we currently don't use them at runtime
const dummySchemaType = null as any;

/**
 * The schema builder.
 *
 * This builder allows you to define the types of documents stored in Convex.
 * @public
 */
export const s = {
  id(): SchemaType<Id, never> {
    return dummySchemaType;
  },
  null(): SchemaType<null, never> {
    return dummySchemaType;
  },
  number(): SchemaType<number, never> {
    return dummySchemaType;
  },
  bigint(): SchemaType<bigint, never> {
    return dummySchemaType;
  },
  boolean(): SchemaType<boolean, never> {
    return dummySchemaType;
  },
  string(): SchemaType<string, never> {
    return dummySchemaType;
  },
  bytes(): SchemaType<ArrayBuffer, never> {
    return dummySchemaType;
  },
  array<T>(values: SchemaType<T, any>): SchemaType<T[], never> {
    return dummySchemaType;
  },
  set<T>(values: SchemaType<T, any>): SchemaType<Set<T>, never> {
    return dummySchemaType;
  },
  map<K, V>(
    keys: SchemaType<K, any>,
    values: SchemaType<V, any>
  ): SchemaType<Map<K, V>, never> {
    return dummySchemaType;
  },
  object<T extends Record<string, SchemaType<any, any>>>(
    schema: T
  ): ObjectSchemaType<T> {
    return dummySchemaType;
  },
  union<
    T extends [
      SchemaType<any, any>,
      SchemaType<any, any>,
      ...SchemaType<any, any>[]
    ]
  >(...schemaTypes: T): UnionSchemaType<T> {
    return dummySchemaType;
  },
};

/**
 * Calculate the {@link SchemaType} for a union.
 *
 * This is used in the SchemaBuilder {@link s}.
 * @public
 */
type UnionSchemaType<SchemaValueType extends SchemaType<any, any>[]> =
  SchemaValueType extends SchemaType<infer InnerType, infer FieldPathsType>[]
    ? SchemaType<InnerType, FieldPathsType>
    : never;

/**
 * Calculate the {@link SchemaType} for an object.
 *
 * This is used within the SchemaBuilder {@link s}.
 * @public
 */
type ObjectSchemaType<
  SchemaValueType extends Record<string, SchemaType<any, any>>
> = SchemaType<
  {
    [Property in keyof SchemaValueType]: SchemaValueType[Property] extends SchemaType<
      infer InnerType,
      any
    >
      ? InnerType
      : never;
  },
  FieldPathsInObject<SchemaValueType>
>;

/**
 * Join together two index field paths.
 *
 * This is used within the SchemaBuilder {@link s}.
 * @public
 */
type JoinFieldPaths<
  Start extends string,
  End extends string
> = `${Start}.${End}`;

/**
 * Calculate all of the index field paths in an object {@link SchemaType}.
 *
 * This is used within the SchemaBuilder {@link s}.
 * @public
 */
type FieldPathsInObject<
  ObjectType extends Record<string, SchemaType<any, any>>
> = {
  [Property in keyof ObjectType]: ObjectType[Property] extends SchemaType<
    any,
    infer FieldPaths
  >
    ? JoinFieldPaths<Property & string, FieldPaths> | Property
    : never;
}[keyof ObjectType] &
  string;

/**
 * Add a property and value onto a TypeScript object type.
 *
 * If the property is present in the object already that field will be
 * overwritten.
 *
 * This is similar to `ObjectType & {PropertyName: Value}` but TypeScript
 * doesn't simplify intersections so in practice this creates cleaner types.
 *
 * @public
 */
type AddPropertyToObjectType<
  ObjectType extends Record<string, any>,
  PropertyName extends string,
  Value
> = {
  [Property in PropertyName | keyof ObjectType]: Property extends PropertyName
    ? Value
    : ObjectType[Property];
};

/**
 * Extract all of the index field paths within a {@link SchemaType}.
 *
 * This is used within {@link defineTable}.
 * @public
 */
type ExtractFieldPaths<T extends SchemaType<any, any>> = T extends SchemaType<
  any,
  infer FieldPaths
>
  ? FieldPaths
  : never;

/**
 * Extract the {@link GenericDocument} within a {@link SchemaType} and
 * add on the `_id` field.
 *
 * This is used within {@link defineTable}.
 * @public
 */
type ExtractDocument<T extends SchemaType<any, any>> = T extends SchemaType<
  infer Value,
  any
>
  ? Value extends Record<string, any>
    ? AddPropertyToObjectType<Value, "_id", Id> & GenericDocument
    : never
  : never;

/**
 * The definition of a table within a schema.
 *
 * This should be produced by using {@link defineTable}.
 * @public
 */
export class TableDefinition<
  Document extends GenericDocument = GenericDocument,
  FieldPaths extends string = string,
  // eslint-disable-next-line @typescript-eslint/ban-types
  TableIndexes extends GenericTableIndexes = {}
> {
  // A map of index name to index fields.
  private indexes: { indexDescriptor: string; fields: string[] }[];

  /**
   * @internal
   */
  constructor() {
    this.indexes = [];
  }

  /**
   * Define an index on this table.
   *
   * To learn about indexes, see [Defining Indexes](https://docs.convex.dev/using/indexes).
   *
   * @param name - The name of the index.
   * @param fields - The fields to index, in order. Must specify at least one
   * field.
   * @returns A {@link TableDefinition} with this index included.
   */
  index<
    IndexName extends string,
    FirstFieldPath extends FieldPaths,
    RestFieldPaths extends FieldPaths[]
  >(
    name: IndexName,
    fields: [FirstFieldPath, ...RestFieldPaths]
  ): TableDefinition<
    Document,
    FieldPaths,
    AddPropertyToObjectType<
      TableIndexes,
      IndexName,
      [FirstFieldPath, ...RestFieldPaths]
    >
  > {
    this.indexes.push({ indexDescriptor: name, fields });
    return this;
  }

  /**
   * Export the contents of this definition.
   *
   * This is called internally by the Convex framework.
   * @internal
   */
  export() {
    return this.indexes;
  }
}

/**
 * Define a table in a schema.
 *
 * You can either specify the schema of your documents as an object like
 * ```ts
 * defineTable({
 *   field: b.string()
 * });
 * ```
 *
 * or as a schema type like
 * ```ts
 * defineTable(b.object({
 *   field: b.string()
 * }));
 * ```
 *
 * @param documentSchema - The type of documents stored in this table.
 * @returns A {@link TableDefinition} for the table.
 *
 * @public
 */
export function defineTable<
  DocumentSchema extends SchemaType<Record<string, any>, any>
>(
  documentSchema: DocumentSchema
): TableDefinition<
  ExtractDocument<DocumentSchema>,
  ExtractFieldPaths<DocumentSchema>
>;
/**
 * Define a table in a schema.
 *
 * You can either specify the schema of your documents as an object like
 * ```ts
 * defineTable({
 *   field: b.string()
 * });
 * ```
 *
 * or as a schema type like
 * ```ts
 * defineTable(b.object({
 *   field: b.string()
 * }));
 * ```
 *
 * @param documentSchema - The type of documents stored in this table.
 * @returns A {@link TableDefinition} for the table.
 *
 * @public
 */
export function defineTable<
  DocumentSchema extends Record<string, SchemaType<any, any>>
>(
  documentSchema: DocumentSchema
): TableDefinition<
  ExtractDocument<ObjectSchemaType<DocumentSchema>>,
  ExtractFieldPaths<ObjectSchemaType<DocumentSchema>>
>;
export function defineTable<
  DocumentSchema extends
    | SchemaType<Record<string, any>, any>
    | Record<string, SchemaType<any, any>>
>(documentSchema: DocumentSchema): TableDefinition<any, any> {
  // For now, ignore the document type because we're just using it for TypeScript
  // types.
  return new TableDefinition();
}

/**
 * A type describing the schema of a Convex project.
 *
 * This should be constructed using {@link defineSchema}, {@link defineTable},
 * and {@link s}.
 * @public
 */
export type GenericSchema = Record<string, TableDefinition>;

/**
 *
 * The definition of a Convex project schema.
 *
 * This should be produced by using {@link defineSchema}.
 * @public
 */
export class SchemaDefinition<Schema extends GenericSchema> {
  private tables: Record<string, TableDefinition>;

  /**
   * @internal
   */
  constructor(tables: Schema) {
    this.tables = tables;
  }

  /**
   * Export the contents of this definition.
   *
   * This is called internally by the Convex framework.
   * @internal
   */
  export(): string {
    return JSON.stringify({
      tables: Object.entries(this.tables).map(([tableName, definition]) => ({
        tableName: tableName,
        indexes: definition.export(),
      })),
    });
  }
}

/**
 * Define the schema of this Convex project.
 *
 * This should be exported from a `schema.ts` file in your `convex/` directory
 * like:
 *
 * ```ts
 * export default defineSchema({
 *   ...
 * });
 * ```
 *
 * @param schema - A map from table name to {@link TableDefinition} for all of
 * the tables in this project.
 * @returns The schema.
 *
 * @public
 */
export function defineSchema<Schema extends GenericSchema>(
  schema: Schema
): SchemaDefinition<Schema> {
  return new SchemaDefinition(schema);
}
