import { Id } from "@convex-dev/common";
import {
  DocumentByName,
  GenericDataModel,
  GenericDocument,
  NamedTableInfo,
  TableNames,
} from "./data_model.js";
import { Table } from "./query.js";
/**
 * A Convex document without the `_id` field.
 *
 * @public
 */
export type WithoutId<Document extends GenericDocument> = Omit<Document, "_id">;

/**
 * An interface to read from the database within Convex query functions.
 *
 * The two entry points are {@link DatabaseReader.get}, which fetches a single
 * document by its {@link values.Id}, or {@link DatabaseReader.table}, which starts
 * building a query.
 *
 * If you're using TypeScript, use the `DatabaseReader` type in
 * `convex/_generated/server.ts` which is typed for your data model.
 *
 * @public
 */
export interface DatabaseReader<DataModel extends GenericDataModel> {
  /**
   * Fetch a single document from the database by its {@link values.Id}.
   *
   * @param id - The {@link values.Id} of the document to fetch from the database.
   * @returns - The {@link GenericDocument} of the document at the given {@link values.Id}, or `null` if it no longer exists.
   */
  get(id: Id): Promise<any | null>;

  /**
   * Begin a query for the given table name.
   *
   * Queries don't execute immediately, so calling this method and extending its
   * query are free until the results are actually used.
   *
   * @param tableName - The name of the table to query.
   * @returns - A {@link Table} object to start building a query.
   */
  table<TableName extends TableNames<DataModel>>(
    tableName: TableName
  ): Table<NamedTableInfo<DataModel, TableName>>;
}

/**
 * An interface to read from and write to the database within Convex mutation
 * functions.
 *
 * Convex guarantees that all writes within a single mutation are
 * executed atomically, so you never have to worry about partial writes leaving
 * your data in an inconsistent state. See [the Convex Guide](https://docs.convex.dev/understanding/convex-fundamentals/functions#atomicity-and-optimistic-concurrency-control)
 * for the guarantees Convex provides your functions.
 *
 *  If you're using TypeScript, use the `DatabaseReader` type in
 * `convex/_generated/server.ts` which is typed for your data model.
 *
 * @public
 */
export interface DatabaseWriter<DataModel extends GenericDataModel>
  extends DatabaseReader<DataModel> {
  /**
   * Insert a new document into a table.
   *
   * @param table - The name of the table to insert a new document into.
   * @param value - The {@link values.Value} to insert into the given table.
   * @returns - {@link values.Id} of the new document.
   */
  insert<TableName extends TableNames<DataModel>>(
    table: TableName,
    value: WithoutId<DocumentByName<DataModel, TableName>>
  ): Id;

  /**
   * Patch an existing document, merging its value with a new values.
   *
   * Any overlapping fields in the two documents will be overwritten with
   * their new value.
   *
   * @param id - The {@link values.Id} of the document to patch.
   * @param value - The partial {@link GenericDocument} to merge into the specified document. If this new value
   * specifies the `_id` field, it must match the document's existing {@link values.Id}.
   */
  patch(id: Id, value: Partial<GenericDocument>): void;

  /**
   * Replace the value of an existing document, overwriting its old value.
   *
   * @param id - The {@link values.Id} of the document to replace.
   * @param value - The new {@link GenericDocument} for the document. This value can omit the `_id` field,
   * and the database will fill it in.
   */
  replace(id: Id, value: GenericDocument): void;

  /**
   * Delete an existing document.
   *
   * @param id - The {@link values.Id} of the document to remove.
   */
  delete(id: Id): void;
}
