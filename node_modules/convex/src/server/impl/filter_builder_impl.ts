import { convexToJson, JSONValue, Value } from "@convex-dev/common";
import {
  Expression,
  ExpressionOrValue,
  FilterBuilder,
} from "../filter_builder.js";

export class ExpressionImpl extends Expression {
  private inner: JSONValue;
  constructor(inner: JSONValue) {
    super();
    this.inner = inner;
  }

  serialize(): JSONValue {
    return this.inner;
  }
}

export function serializeExpression(expr: ExpressionOrValue): JSONValue {
  if (expr instanceof ExpressionImpl) {
    return expr.serialize();
  } else {
    // Assume that the expression is a literal Convex value, which we'll serialize
    // to its JSON representation.
    return { $literal: convexToJson(expr as Value) };
  }
}

export const filterBuilderImpl: FilterBuilder = {
  //  Comparisons  /////////////////////////////////////////////////////////////

  eq(l: ExpressionOrValue, r: ExpressionOrValue): Expression {
    return new ExpressionImpl({
      $eq: [serializeExpression(l), serializeExpression(r)],
    });
  },

  neq(l: ExpressionOrValue, r: ExpressionOrValue): Expression {
    return new ExpressionImpl({
      $neq: [serializeExpression(l), serializeExpression(r)],
    });
  },

  lt(l: ExpressionOrValue, r: ExpressionOrValue): Expression {
    return new ExpressionImpl({
      $lt: [serializeExpression(l), serializeExpression(r)],
    });
  },

  lte(l: ExpressionOrValue, r: ExpressionOrValue): Expression {
    return new ExpressionImpl({
      $lte: [serializeExpression(l), serializeExpression(r)],
    });
  },

  gt(l: ExpressionOrValue, r: ExpressionOrValue): Expression {
    return new ExpressionImpl({
      $gt: [serializeExpression(l), serializeExpression(r)],
    });
  },

  gte(l: ExpressionOrValue, r: ExpressionOrValue): Expression {
    return new ExpressionImpl({
      $gte: [serializeExpression(l), serializeExpression(r)],
    });
  },

  //  Arithmetic  //////////////////////////////////////////////////////////////

  add(l: ExpressionOrValue, r: ExpressionOrValue): Expression {
    return new ExpressionImpl({
      $add: [serializeExpression(l), serializeExpression(r)],
    });
  },

  sub(l: ExpressionOrValue, r: ExpressionOrValue): Expression {
    return new ExpressionImpl({
      $sub: [serializeExpression(l), serializeExpression(r)],
    });
  },

  mul(l: ExpressionOrValue, r: ExpressionOrValue): Expression {
    return new ExpressionImpl({
      $mul: [serializeExpression(l), serializeExpression(r)],
    });
  },

  div(l: ExpressionOrValue, r: ExpressionOrValue): Expression {
    return new ExpressionImpl({
      $div: [serializeExpression(l), serializeExpression(r)],
    });
  },

  mod(l: ExpressionOrValue, r: ExpressionOrValue): Expression {
    return new ExpressionImpl({
      $mod: [serializeExpression(l), serializeExpression(r)],
    });
  },

  neg(x: Expression): Expression {
    return new ExpressionImpl({ $neg: serializeExpression(x) });
  },

  //  Logic  ///////////////////////////////////////////////////////////////////

  and(...exprs: Array<Expression>): Expression {
    return new ExpressionImpl({ $and: exprs.map(serializeExpression) });
  },

  or(...exprs: Array<Expression>): Expression {
    return new ExpressionImpl({ $or: exprs.map(serializeExpression) });
  },

  not(x: ExpressionOrValue): Expression {
    return new ExpressionImpl({ $not: serializeExpression(x) });
  },

  //  Other  ///////////////////////////////////////////////////////////////////
  field(fieldPath: string): Expression {
    return new ExpressionImpl({ $field: fieldPath });
  },
};
