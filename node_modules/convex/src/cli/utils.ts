import axios, { AxiosResponse } from "axios";
import chalk from "chalk";
import * as readline from "readline";
import fs from "fs/promises";
import * as Sentry from "@sentry/node";
import path from "path";
import os from "os";
import { z } from "zod";
import { Option } from "commander";

import { version } from "../index.js";
import { InstanceConfig } from "./config.js";

/** Prompt for keyboard input with the given `query` string and return a promise
 * that resolves to the input. */
export function prompt(query: string) {
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
  });
  return new Promise(resolve =>
    rl.question(query, answer => {
      rl.close();
      resolve(answer);
    })
  );
}

/**
 * Exits the program after flushing the Sentry client, optionally reporting a passed exception.
 *
 * Callers should `return await flushAndExit(...)` to ensure that control flow is blocked until completion.
 * @param exitCode Exit code for the program (should be non-zero in case of error)
 * @param err Optional exception to be reported to Sentry. Generally this should be reserved for "unexpected" fatal errors rather than clear developer errors.
 * @returns Never returns, i.e. this function is diverging and returns `Promise<never>`.
 */
export async function flushAndExit(exitCode: number, err?: any) {
  if (err) {
    Sentry.captureException(err);
  }
  await Sentry.close();
  // eslint-disable-next-line no-restricted-syntax
  return process.exit(exitCode);
}

export function printServerErr(err: any) {
  const res = err.response;
  if (res) {
    console.error(
      chalk.gray(
        `${res.status} ${res.statusText}: ${res.data.code}: ${res.data.message}`
      )
    );
    deprecationCheck(res);
  } else {
    console.error(chalk.gray(err));
  }
}

export function deprecationCheck(resp: AxiosResponse<any, any>) {
  const headers = resp.headers;
  if (headers) {
    const deprecationState = headers["x-convex-deprecation-state"];
    const deprecationMessage = headers["x-convex-deprecation-message"];
    switch (deprecationState) {
      case undefined:
        break;
      case "Deprecated":
        console.log(chalk.red(deprecationMessage));
        break;
      case "Upgradable":
        console.log(chalk.yellow(deprecationMessage));
        break;
      case "UpgradeCritical":
        console.log(chalk.red(deprecationMessage));
        break;
      default:
        console.log(deprecationMessage);
        break;
    }
  }
}

class PackageJsonLoadError extends Error {}

export interface Package {
  name: string;
  version: string;
}

export async function loadPackageJson(): Promise<Package[]> {
  let packageJson;
  try {
    packageJson = await fs.readFile("package.json", { encoding: "utf-8" });
  } catch (err) {
    console.error(
      chalk.red(
        `Unable to read your package.json: ${err}. Make sure you're running this command from the root directory of a Convex app that contains the package.json`
      )
    );
    return await flushAndExit(1);
  }
  let obj;
  try {
    obj = JSON.parse(packageJson);
  } catch (err) {
    console.error(chalk.red(`Unable to parse package.json: ${err}`));
    return await flushAndExit(1, err);
  }
  if (typeof obj !== "object") {
    throw new PackageJsonLoadError(
      "Expected to parse an object from package.json"
    );
  }
  const packages = [];
  if (obj.dependencies) {
    for (const dep in obj.dependencies) {
      packages.push({ name: dep, version: obj.dependencies[dep] });
    }
  }
  if (obj.devDependencies) {
    for (const dep in obj.devDependencies) {
      packages.push({ name: dep, version: obj.devDependencies[dep] });
    }
  }
  return packages;
}

// Check that all Convex packages in package.json are the same version, printing error and returning false if not
export async function pkgVersionConsistencyCheck(origin: string) {
  const convexPackages: Package[] = (await loadPackageJson()).filter(
    isConvexPackage
  );
  const url = `${origin}/api/${version}/check_version_consistency`;
  const client = axios.create();
  return client
    .put(url, { packages: convexPackages })
    .then(res => {
      if (res.data.message) {
        console.error(chalk.red(res.data.message));
      }
    })
    .catch(err => {
      printServerErr(err);
    });
}

export const isConvexPackage = (elt: Package) =>
  elt.name.startsWith("@convex-dev") || elt.name.startsWith("convex");

/** Return a new array with elements of the passed in array sorted by a key lambda */
export const sorted = <T>(arr: T[], key: (el: T) => any): T[] => {
  const newArr = [...arr];
  const cmp = (a: T, b: T) => {
    if (key(a) < key(b)) return -1;
    if (key(a) > key(b)) return 1;
    return 0;
  };
  return newArr.sort(cmp);
};

export async function exists(path: string) {
  try {
    await fs.access(path);
    return true;
  } catch {
    return false;
  }
}

export function functionsDir(
  configPath: string,
  instanceConfig: InstanceConfig
): string {
  return path.join(path.dirname(configPath), instanceConfig.functions);
}

export function rootDirectory(): string {
  let dirName;
  // Use a different directory for config files generated for tests
  if (process.env.USE_TEST_CONFIG_DIR) {
    dirName = ".convex-test";
  } else {
    dirName = ".convex";
  }
  return path.join(os.homedir(), dirName);
}
export function globalConfigPath(): string {
  return path.join(rootDirectory(), "config.json");
}

async function readGlobalConfig(): Promise<GlobalConfig | null> {
  const configPath = globalConfigPath();
  let configFile;
  try {
    configFile = await fs.readFile(configPath, { encoding: "utf-8" });
  } catch (err) {
    console.error(
      chalk.red(
        `Failed to read global config in ${configPath}. Please run \`npx convex login\` to generate your global config.`
      )
    );
    return null;
  }
  try {
    const schema = z.object({
      accessToken: z.string().min(1),
    });
    const config: GlobalConfig = schema.parse(JSON.parse(configFile));
    return config;
  } catch (err) {
    console.error(
      chalk.red(
        `Failed to parse global config in ${configPath} with error ${err}. Please run \`npx convex login\` to regenerate your global config.`
      )
    );
    return null;
  }
}

export async function getAuthHeader(): Promise<string | null> {
  const globalConfig = await readGlobalConfig();
  if (globalConfig) {
    return `Bearer ${globalConfig.accessToken}`;
  }
  return null;
}

export type GlobalConfig = {
  accessToken: string;
};

export const BETA_KEY_DEPRECATION_MESSAGE =
  "Convex beta keys are deprecated. Please run `npx convex login` to log in.";

export const BETA_KEY_OPTION = new Option(
  "--beta-key [key]",
  `Convex beta key for the closed beta. ${BETA_KEY_DEPRECATION_MESSAGE}`
).hideHelp();

/**
 * Polls an arbitrary function until a condition is met.
 *
 * @param fetch Function performing a fetch, returning resulting data.
 * @param condition This function will terminate polling when it returns `true`.
 * @param waitMs How long to wait in between fetches.
 * @returns The resulting data from `fetch`.
 */
export const poll = async function <Result>(
  fetch: () => Promise<Result>,
  condition: (data: Result) => boolean,
  waitMs = 1000
) {
  let result = await fetch();
  while (!condition(result)) {
    await wait(waitMs);
    result = await fetch();
  }
  return result;
};

const wait = function (waitMs: number) {
  return new Promise(resolve => {
    setTimeout(resolve, waitMs);
  });
};
