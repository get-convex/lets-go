import axios from "axios";
import fs from "fs";
import path from "path";
import prettier from "prettier";
import { Command, Option } from "commander";
import {
  Config,
  configFromInstanceConfig,
  configJSON,
  InstanceConfig,
  mustReadEnv,
  readInstanceConfig,
} from "./config.js";
import chalk from "chalk";
import {
  deprecationCheck,
  flushAndExit,
  functionsDir,
  pkgVersionConsistencyCheck,
  printServerErr,
  sorted,
} from "./utils.js";
import { version } from "../index.js";
import { jsonToConvex } from "@convex-dev/common";
import { reactCodegen, Udf } from "./codegen_templates/react.js";
import {
  dataModelCodegen,
  dataModelCodegenWithoutSchema,
} from "./codegen_templates/dataModel.js";
import { serverCodegen } from "./codegen_templates/server.js";
import {
  doTypeCheck,
  processTypeCheckResult,
  typeCheckFunctions,
  TypeCheckMode,
} from "./typecheck.js";

export const codegen = new Command("codegen")
  .description(
    "Generate a client for the current contents of the convex/ directory"
  )
  .option("-v, --verbose", "Show full listing of changes")
  .option(
    "--dry-run",
    "Print out the generated configuration to stdout instead of writing to convex directory"
  )
  .addOption(new Option("--debug").hideHelp())
  .addOption(
    new Option(
      "--typecheck <mode>",
      `Whether to check TypeScript files with \`tsc --noEmit\`.`
    )
      .choices(["enable", "try", "disable"])
      .default("disable")
  )
  .action(async options => {
    const adminKey = (await mustReadEnv(options.deploymentType)).adminKey;
    const { instanceConfig, configPath } = await readInstanceConfig(
      options.deploymentType
    );
    await pkgVersionConsistencyCheck(instanceConfig.origin);

    if (options.typecheck !== "disable") {
      console.error(
        chalk.gray(
          "Trying experimental TypeScript typecheck, remove --typecheck=enable to disable."
        )
      );
    }

    await doCodegen({
      instanceConfig,
      configPath,
      adminKey,
      typeCheckMode: options.typecheck,
      dryRun: options.dryRun,
      debug: options.debug,
      verbose: options.verbose,
    });
    chalk.green("Codegen finished.");
  });

type Modules = Map<
  string,
  {
    functions: {
      lineno: number;
      name: string;
      isQuery: boolean;
      isMutation: boolean;
    }[];
    source: string;
  }
>;

/**
 * Computes all the query and mutation functions defined in the convex/
 * directory by shipping the bundled source to the backend.
 */
async function determineFunctions(
  config: Config,
  adminKey: string
): Promise<{ modules: Modules }> {
  const serializedConfig = configJSON(config, adminKey);
  try {
    const res = await axios.post(
      `${config.instanceConfig.origin}/api/${version}/analyze_config`,
      serializedConfig
    );
    deprecationCheck(res);
    return jsonToConvex(res.data) as { modules: Modules };
  } catch (err) {
    console.error(
      chalk.red(
        "Error: Unable to determine Convex functions",
        config.instanceConfig.origin
      )
    );
    printServerErr(err);
    return await flushAndExit(1, err);
  }
}

/**
 * Run prettier so we don't have to think about formatting!
 *
 * This is a little sketchy because we are using the default prettier config
 * (not our user's one) but it's better than nothing.
 */
function format(source: string): string {
  return prettier.format(source, { parser: "typescript" });
}

function writeFile(
  filename: string,
  source: string,
  codegenDir: string,
  dryRun: boolean,
  debug: boolean
) {
  const formattedSource = format(source);
  const dest = path.join(codegenDir, filename);
  if (debug) {
    console.log(`# ${dest}`);
    console.log(formattedSource);
    return;
  }
  if (dryRun) {
    if (fs.existsSync(dest)) {
      const fileText = fs.readFileSync(dest, "utf8");
      if (fileText !== formattedSource) {
        console.log(`Command would replace file: ${dest}`);
      }
    } else {
      console.log(`Command would create file: ${dest}`);
    }
    return;
  }

  console.log(`writing ${dest}`);
  fs.writeFileSync(dest, formattedSource, "utf8");
}

function doServerCodegen(
  codegenDir: string,
  dryRun: boolean,
  hasSchemaFile: boolean,
  debug: boolean
) {
  if (hasSchemaFile) {
    writeFile("dataModel.ts", dataModelCodegen(), codegenDir, dryRun, debug);
  } else {
    writeFile(
      "dataModel.ts",
      dataModelCodegenWithoutSchema(),
      codegenDir,
      dryRun,
      debug
    );
  }
  writeFile("server.ts", serverCodegen(), codegenDir, dryRun, debug);
}

async function doReactCodegen(
  config: Config,
  adminKey: string,
  codegenDir: string,
  dryRun: boolean,
  debug: boolean
) {
  const { modules } = await determineFunctions(config, adminKey);
  const udfs: Udf[] = [];
  const filenames = [...modules.keys()].sort();
  for (const filename of filenames) {
    const udfsInModule = sorted(
      modules.get(filename)!.functions,
      udf => udf.name
    );
    for (const udf of udfsInModule) {
      udfs.push({
        filename,
        name: udf.name,
        isQuery: udf.isQuery,
        isMutation: udf.isMutation,
      });
    }
  }

  writeFile("react.ts", reactCodegen(udfs), codegenDir, dryRun, debug);
}

export async function doCodegen({
  instanceConfig,
  configPath,
  adminKey,
  typeCheckMode,
  dryRun = false,
  verbose = false,
  warnOnMissingSchemaFile = true,
  debug = false,
}: {
  instanceConfig: InstanceConfig;
  configPath: string;
  adminKey: string;
  typeCheckMode: TypeCheckMode;
  dryRun?: boolean;
  debug?: boolean;
  verbose?: boolean;
  warnOnMissingSchemaFile?: boolean;
}): Promise<Config> {
  const funcDir = functionsDir(configPath, instanceConfig);

  // Delete the old _generated.ts because v0.1.2 used to put the react generated
  // code there
  const legacyCodegenPath = path.join(funcDir, "_generated.ts");
  if (fs.existsSync(legacyCodegenPath)) {
    if (!dryRun) {
      console.log(`Deleting legacy codegen file: ${legacyCodegenPath}}`);
      fs.rmSync(legacyCodegenPath);
    } else {
      console.log(
        `Command would delete legacy codegen file: ${legacyCodegenPath}}`
      );
    }
  }

  // Create the codegen dir if it doesn't already exist.
  const codegenDir = path.join(funcDir, "_generated");
  if (!fs.existsSync(codegenDir)) {
    fs.mkdirSync(codegenDir);
  }

  const schemaPath = path.join(funcDir, "schema.ts");
  const hasSchemaFile = fs.existsSync(schemaPath);
  if (warnOnMissingSchemaFile && !hasSchemaFile) {
    console.warn(
      chalk.yellow(
        `Did not find a schema file at \`${schemaPath}\`. The generated code will consider documents to have the \`any\` type. To add a schema see https://docs.convex.dev/using/schemas`
      )
    );
  }

  // Do things in a careful order so that we always:
  // - typecheck sources before we use them.
  // - generate code in dependency order.
  //
  // The dependency chain is:
  // _generated/react.ts
  // -> query and mutation functions
  // -> _generated/server.ts
  // -> schema.ts
  // (where -> means "depends on")

  // 1. Typecheck the schema.ts file
  if (hasSchemaFile) {
    await processTypeCheckResult(typeCheckMode, () =>
      doTypeCheck([path.join(funcDir, "schema.ts")])
    );
  }

  // 2. Use the schema.ts file to create the server codegen
  doServerCodegen(codegenDir, dryRun, hasSchemaFile, debug);

  // 3. Typecheck the query and mutation functions
  await processTypeCheckResult(typeCheckMode, () =>
    typeCheckFunctions(funcDir)
  );

  // 4. Bundle the query and mutation functions
  const config = await configFromInstanceConfig(
    instanceConfig,
    configPath,
    verbose
  );

  // 5. Generate the React code
  await doReactCodegen(config, adminKey, codegenDir, dryRun, debug);

  // Return the config so other code won't bundle twice.
  return config;
}
