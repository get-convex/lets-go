import chalk from "chalk";
import fs from "fs/promises";
import axios from "axios";
import equal from "deep-equal";
import path from "path";
import { Bundle, bundleAll } from "../bundler/index.js";
import { version } from "../index.js";
import { parse as envfileParse } from "envfile";
import axiosRetry from "axios-retry";
import {
  deprecationCheck,
  exists,
  flushAndExit,
  functionsDir,
  loadPackageJson,
  printServerErr,
} from "./utils.js";

export const productionProvisionHost = "https://provision.convex.dev";
export const provisionHost =
  process.env.CONVEX_PROVISION_HOST || productionProvisionHost;

/** Type representing auth configuration. */
export interface AuthInfo {
  // Provider-specific application identifier. Corresponds to the `aud` field in an OIDC token.
  applicationID: string;
  // Domain used for authentication. Corresponds to the `iss` field in an OIDC token.
  domain: string;
}

/** Type representing Convex deployment configuration. */
export interface InstanceConfig {
  instanceName: string;
  origin: string;
  functions: string;
  authInfo: AuthInfo[];
}

export interface Config {
  instanceConfig: InstanceConfig;
  modules: Bundle[];
  udfServerVersion?: string;
}

/** Check if object is of AuthInfo type. */
function isAuthInfo(object: any): object is AuthInfo {
  return (
    "applicationID" in object &&
    typeof object.applicationID === "string" &&
    "domain" in object &&
    typeof object.domain === "string"
  );
}

function isAuthInfos(object: any): object is AuthInfo[] {
  return Array.isArray(object) && object.every((item: any) => isAuthInfo(item));
}

/** Error parsing InstanceConfig representation. */
class ParseError extends Error {}

/** Parse object to InstanceConfig. */
export function parseConfig(obj: any): InstanceConfig {
  if (typeof obj !== "object") {
    throw new ParseError("Expected an object");
  }
  if (typeof obj.origin !== "string") {
    throw new ParseError("Expected origin to be a string");
  }
  if (obj.instanceName && typeof obj.instanceName !== "string") {
    throw new ParseError("Expected deployment name to be a string");
  }
  if (typeof obj.functions !== "string") {
    throw new ParseError("Expected functions to be a string");
  }

  // Allow the `authInfo` key to be omitted, treating it as an empty list of providers.
  obj.authInfo = obj.authInfo ?? [];
  if (!isAuthInfos(obj.authInfo)) {
    throw new ParseError("Expected authInfo to be type AuthInfo[]");
  }

  // Important! We return the object itself (not a new object) because
  // we want to ensure that fields we're unaware of are "passed through".
  // It's possible that this is an old client and the server knows about new
  // fields that we don't.
  return obj;
}

export function configName(deployment: string | null): string {
  if (deployment == null) {
    return "convex.json";
  } else {
    if (deployment == "") {
      throw new Error("Can't have empty string for deployment");
    }
    return `convex.${deployment}.json`;
  }
}

export async function configFilepath(configFn: string): Promise<string> {
  const packages = await loadPackageJson();
  const isCreateReactApp = !!packages.filter(
    ({ name }) => name === "react-scripts"
  ).length;

  // create-react-app (aka react-scripts) requires all src files be in src/
  // so prefer src/convex.json on init.
  const standardLocation = configFn;
  const srcLocation = path.join("src", configFn);
  const [preferredLocation, wrongLocation] = isCreateReactApp
    ? [srcLocation, standardLocation]
    : [standardLocation, srcLocation];

  // Allow either location, but not both.
  const standardLocationExists = await exists(standardLocation);
  const srcLocationExists = await exists(srcLocation);
  if (standardLocationExists && srcLocationExists) {
    console.error(
      chalk.red(
        `Error: both ${preferredLocation} and ${wrongLocation} files exist!`
      )
    );
    console.error(`Consolidate these and remove ${wrongLocation}.`);
    return await flushAndExit(1);
  }
  if (preferredLocation === standardLocation) {
    return preferredLocation;
  }

  try {
    await fs.access("src");
  } catch (e) {
    console.error(
      chalk.red(
        `Error: use of create-react-app detected (found react-scripts in package.json) but no src directory found.`
      )
    );
    return await flushAndExit(1);
  }
  return preferredLocation;
}

/** Read configuration from a local `convex.json` file. */
export async function readInstanceConfig(
  deployment: string | null
): Promise<{ instanceConfig: InstanceConfig; configPath: string }> {
  let instanceConfig;
  const configFn = configName(deployment);
  const configPath = await configFilepath(configFn);
  try {
    instanceConfig = parseConfig(
      JSON.parse(await fs.readFile(configPath, { encoding: "utf-8" }))
    );
  } catch (err) {
    if (err instanceof ParseError || err instanceof SyntaxError) {
      console.error(chalk.red(`Error: Parsing "${configPath}" failed`));
      console.error(chalk.gray(err.toString()));
    } else {
      console.error(
        chalk.red(
          `Error: Unable to read deployment config file "${configPath}"`
        )
      );
      console.error(
        "Are you running this command from the root directory of a Convex app?"
      );
      if (err instanceof Error) {
        console.error(chalk.gray(err.message));
      }
    }
    return await flushAndExit(1, err);
  }
  return {
    instanceConfig,
    configPath,
  };
}

/**
 * Given an {@link InstanceConfig}, add in the bundled modules to produce the
 * complete config.
 */
export async function configFromInstanceConfig(
  instanceConfig: InstanceConfig,
  configPath: string,
  verbose: boolean
): Promise<Config> {
  let modules;
  try {
    modules = await bundleAll(
      functionsDir(configPath, instanceConfig),
      true,
      verbose
    );
  } catch (err) {
    console.error(chalk.red("Error: Unable to bundle Convex modules"));
    if (err instanceof Error) {
      console.error(chalk.gray(err.message));
    }
    return await flushAndExit(1, err);
  }

  return {
    instanceConfig: instanceConfig,
    modules: modules,
    // We're just using the version this CLI is running with for now.
    // This could be different than the version of `convex` the app runs with
    // if the CLI is installed globally.
    udfServerVersion: version,
  };
}

/**
 * Read the config from `convex.json` and bundle all the modules.
 */
export async function readConfig(
  deployment: string | null,
  verbose: boolean
): Promise<{ config: Config; configPath: string }> {
  const { instanceConfig, configPath } = await readInstanceConfig(deployment);
  const config = await configFromInstanceConfig(
    instanceConfig,
    configPath,
    verbose
  );
  return { config, configPath };
}

interface Env {
  adminKey: string;
}

export async function mustReadEnv(deployment: string): Promise<Env> {
  const envFn = envFilename(deployment);
  const env = await readEnv(deployment);
  if (env != null) {
    return env;
  }
  try {
    await fs.access("convex.json");
  } catch (err) {
    console.error(
      "Are you running this command from the root directory of an initialized Convex app? We couldn't find your convex.json"
    );
    return await flushAndExit(1);
  }
  console.error(
    chalk.red(
      `Error: Unable to find the CONVEX_ADMIN_KEY environment variable.\nHave you set your CONVEX_ADMIN_KEY in "${envFn}" or in your environment variables?`
    )
  );
  console.error("");
  console.error("  CONVEX_ADMIN_KEY=<your deployment's admin key>");
  console.error("");
  return await flushAndExit(1);
}

export function envFilename(deployment: string | null): string {
  if (deployment == null) {
    return ".env.local";
  } else {
    if (deployment == "") {
      throw new Error("Can't have empty string for deployment");
    }
    return `.env.${deployment}.local`;
  }
}

export async function readEnv(deployment: string): Promise<Env | null> {
  if (process.env.CONVEX_ADMIN_KEY) {
    return { adminKey: process.env.CONVEX_ADMIN_KEY };
  }

  let envContents;
  try {
    envContents = await fs.readFile(envFilename(deployment), {
      encoding: "utf-8",
    });
  } catch (err) {
    return null;
  }
  const envFile = envfileParse(envContents);
  const adminKey = envFile["CONVEX_ADMIN_KEY"];
  if (!adminKey || adminKey == "undefined") {
    return null;
  }
  return { adminKey };
}

/** Write a README file in `{config/functions}/README.md` */
export async function writeReadme(functionsDir: string) {
  const readmeFileName = "README.md";
  const readmeUrl = `${provisionHost}/api/${version}/readme/`;
  const client = axios.create();
  return client.get(readmeUrl).then(async res => {
    const readme = res.data.readme;
    let readmeFile: fs.FileHandle;
    try {
      readmeFile = await fs.open(functionsDir + readmeFileName, "w", 0o644);
    } catch (err) {
      console.error(
        chalk.red(
          'Error: Unable to open file "README.md" for writing in "' +
            functionsDir +
            '"'
        )
      );
      console.error(
        "Are you running this command from the root directory of a Convex app?"
      );
      return await flushAndExit(1);
    }
    try {
      await readmeFile.writeFile(readme + "\n");
    } catch (err) {
      return await flushAndExit(1, err);
    } finally {
      readmeFile.close();
    }
  });
}

/** Write the config to `convex.json` in the current working directory. */
export async function writeInstanceConfig(
  deployment: string,
  instanceConfig: InstanceConfig
) {
  const configFn = configName(deployment);
  const configPath = await configFilepath(configFn);
  let configFile: fs.FileHandle;
  try {
    configFile = await fs.open(configPath, "w", 0o644);
  } catch (err) {
    console.error(
      chalk.red(
        `Error: Unable to open deployment config file "${configPath}" for writing in current directory`
      )
    );
    console.error(
      "Are you running this command from the root directory of a Convex app?"
    );
    return await flushAndExit(1);
  }
  try {
    await configFile.writeFile(
      JSON.stringify(instanceConfig, undefined, 2) + "\n"
    );
  } catch (err) {
    console.error(
      chalk.red(`Error: Unable to write deployment config file "${configPath}"`)
    );
    return await flushAndExit(1, err);
  } finally {
    configFile.close();
  }
  try {
    await fs.mkdir(functionsDir(configPath, instanceConfig));
  } catch (err) {
    // skipping error
  }

  await writeReadme(functionsDir(configPath, instanceConfig));
}

export async function writeAdminKey(deployment: string, adminKey: string) {
  if (!adminKey) {
    console.error(chalk.red(`Error: unexpected - admin key is missing`));
    return await flushAndExit(1);
  }
  const envFn = envFilename(deployment);
  let envLocalFile: fs.FileHandle;
  try {
    envLocalFile = await fs.open(envFn, "w", 0o644);
  } catch (err) {
    console.error(
      chalk.red(`Error: Unable to open file "${envFn}" in current directory`)
    );
    console.error(
      "Are you running this command from the root directory of a Convex app?"
    );
    return await flushAndExit(1);
  }
  try {
    await envLocalFile.writeFile(`CONVEX_ADMIN_KEY=${adminKey}\n`);
  } catch (err) {
    console.error(
      chalk.red(
        `Error: Unable to write file "${envFilename}" in current directory`
      )
    );
    return await flushAndExit(1, err);
  } finally {
    envLocalFile.close();
  }
}

/** Pull configuration from the given remote origin. */
export async function pullConfig(
  origin: string,
  adminKey: string
): Promise<Config> {
  const client = axios.create();
  axiosRetry(client, {
    retries: 4,
    retryDelay: axiosRetry.exponentialDelay,
    retryCondition: error => {
      return error.response?.status == 404 || false;
    },
  });
  try {
    const res = await client.post(
      `${origin}/api/${version}/get_config`,
      { version, adminKey },
      {
        maxContentLength: Infinity,
      }
    );
    deprecationCheck(res);
    return {
      instanceConfig: parseConfig(res.data.config),
      modules: res.data.modules,
      udfServerVersion: res.data.udfServerVersion,
    };
  } catch (err) {
    console.error(
      chalk.red("Error: Unable to pull deployment config from", origin)
    );
    printServerErr(err);
    return await flushAndExit(1, err);
  }
}

export function configJSON(config: Config, adminKey: string) {
  return {
    // TODO: Remove this since it's being passed up in the URL.
    version,
    config: config.instanceConfig,
    modules: config.modules,
    udfServerVersion: config.udfServerVersion,
    adminKey,
  };
}

/** Push configuration to the given remote origin. */
export async function pushConfig(
  config: Config,
  adminKey: string
): Promise<void> {
  const serializedConfig = configJSON(config, adminKey);
  const origin = config.instanceConfig.origin;
  try {
    await axios.post(`${origin}/api/${version}/push_config`, serializedConfig, {
      maxContentLength: Infinity,
      maxBodyLength: Infinity,
    });
  } catch (err) {
    console.error(
      chalk.red("Error: Unable to push deployment config to", origin)
    );
    printServerErr(err);
    return await flushAndExit(1, err);
  }
}

type Files = { source: string; filename: string }[];

export type CodegenResponse =
  | {
      success: true;
      files: Files;
    }
  | {
      success: false;
      error: string;
    };

// We can eventually switch to something like `filesize` for i18n and
// more robust formatting, but let's keep our CLI bundle small for now.
function formatSize(n: number): string {
  if (n < 1024) {
    return `${n} B`;
  }
  if (n < 1024 * 1024) {
    return `${Math.floor(n / 1024)} KB`;
  }
  if (n < 1024 * 1024 * 1024) {
    return `${Math.floor(n / 1024 / 1024)} MB`;
  }
  return `${n} B`;
}

function isDepsPath(modulePath: string): boolean {
  return modulePath.startsWith("_deps/");
}

function renderModule(
  functions: string,
  module: Bundle,
  verbose: boolean
): string {
  const relPath = path.join(functions, module.path);
  if (verbose) {
    const sourceMapSize = formatSize(module.sourceMap?.length ?? 0);
    return (
      relPath +
      ` (${formatSize(module.source.length)}, source map ${sourceMapSize})`
    );
  }
  return relPath;
}

/** Generate a human-readable diff between the two configs. */
export function diffConfig(
  oldConfig: Config,
  newConfig: Config,
  configPath: string,
  verbose: boolean
): string {
  let diff = "";

  const droppedModules = [];
  for (const oldModule of oldConfig.modules) {
    let matches = false;
    for (const newModule of newConfig.modules) {
      const oldPath = path.join(
        oldConfig.instanceConfig.functions,
        oldModule.path
      );
      const newPath = path.join(
        newConfig.instanceConfig.functions,
        newModule.path
      );
      if (
        oldPath === newPath &&
        oldModule.source === newModule.source &&
        oldModule.sourceMap === newModule.sourceMap
      ) {
        matches = true;
        break;
      }
    }
    if (!matches) {
      if (!isDepsPath(oldModule.path) || verbose) {
        droppedModules.push(oldModule);
      }
    }
  }
  if (droppedModules.length > 0) {
    diff += "Delete the following modules:\n";
    for (const module of droppedModules) {
      diff +=
        "[-] " +
        renderModule(
          functionsDir(configPath, oldConfig.instanceConfig),
          module,
          verbose
        ) +
        "\n";
    }
  }

  const addedModules = [];
  for (const newModule of newConfig.modules) {
    let matches = false;
    for (const oldModule of oldConfig.modules) {
      const oldPath = path.join(
        oldConfig.instanceConfig.functions,
        oldModule.path
      );
      const newPath = path.join(
        newConfig.instanceConfig.functions,
        newModule.path
      );
      if (
        oldPath === newPath &&
        oldModule.source === newModule.source &&
        oldModule.sourceMap === newModule.sourceMap
      ) {
        matches = true;
        break;
      }
    }
    if (!matches) {
      if (!isDepsPath(newModule.path) || verbose) {
        addedModules.push(newModule);
      }
    }
  }
  if (addedModules.length > 0) {
    diff += "Add the following modules:\n";
    for (const module of addedModules) {
      diff +=
        "[+] " +
        renderModule(
          functionsDir(configPath, newConfig.instanceConfig),
          module,
          verbose
        ) +
        "\n";
    }
  }
  const droppedAuth = [];
  for (const oldAuth of oldConfig.instanceConfig.authInfo) {
    let matches = false;
    for (const newAuth of newConfig.instanceConfig.authInfo) {
      if (equal(oldAuth, newAuth)) {
        matches = true;
        break;
      }
    }
    if (!matches) {
      droppedAuth.push(oldAuth);
    }
  }
  if (droppedAuth.length > 0) {
    diff += "Remove the following auth providers:\n";
    for (const authInfo of droppedAuth) {
      diff += "[-] " + JSON.stringify(authInfo) + "\n";
    }
  }

  const addedAuth = [];
  for (const newAuth of newConfig.instanceConfig.authInfo) {
    let matches = false;
    for (const oldAuth of oldConfig.instanceConfig.authInfo) {
      if (equal(newAuth, oldAuth)) {
        matches = true;
        break;
      }
    }
    if (!matches) {
      addedAuth.push(newAuth);
    }
  }
  if (addedAuth.length > 0) {
    diff += "Add the following auth providers:\n";
    for (const auth of addedAuth) {
      diff += "[+] " + JSON.stringify(auth) + "\n";
    }
  }

  if (verbose) {
    let versionMessage = "";
    const matches = oldConfig.udfServerVersion === newConfig.udfServerVersion;
    if (
      oldConfig.udfServerVersion &&
      (!newConfig.udfServerVersion || !matches)
    ) {
      versionMessage += `[-] ${oldConfig.udfServerVersion}\n`;
    }
    if (
      newConfig.udfServerVersion &&
      (!oldConfig.udfServerVersion || !matches)
    ) {
      versionMessage += `[+] ${newConfig.udfServerVersion}\n`;
    }
    if (versionMessage) {
      diff += "Change the server's function version:\n";
      diff += versionMessage;
    }
  }

  return diff;
}
