import { Command, Option } from "commander";
import chalk from "chalk";
import {
  mustReadEnv,
  pullConfig,
  pushConfig,
  diffConfig,
  readInstanceConfig,
  configFromInstanceConfig,
  Config,
  configJSON,
} from "./config.js";
import {
  flushAndExit,
  functionsDir,
  pkgVersionConsistencyCheck,
} from "./utils.js";
import { processTypeCheckResult, typeCheckFunctions } from "./typecheck.js";
import { doCodegen } from "./codegen.js";
import { buildIndexes } from "./indexes.js";

/** Pull the local config and overwrite the remote one. */
export const push = new Command("push")
  .description("Push local Convex functions and configuration to a deployment")
  .option("-v, --verbose", "Show full listing of changes")
  .option(
    "--dry-run",
    "Print out the generated configuration without sending it to the server"
  )
  .addOption(
    new Option(
      "--typecheck <mode>",
      `Whether to check TypeScript files with \`tsc --noEmit\` before pushing.`
    )
      .choices(["enable", "try", "disable"])
      .default("disable")
  )
  .addOption(new Option("--debug").hideHelp())
  .addOption(
    new Option("--codegen <mode>", "Whether to regenerate client code on push.")
      .choices(["enable", "disable"])
      .default("enable")
  )
  .option(
    "--deployment-type <type>",
    "Type of deployment to push to (`convex.<type>.json`). Defaults to `convex.json`"
  )
  .action(async options => {
    const adminKey = (await mustReadEnv(options.deploymentType)).adminKey;
    const { configPath, instanceConfig } = await readInstanceConfig(
      options.deploymentType
    );
    const origin = instanceConfig.origin;
    await pkgVersionConsistencyCheck(origin);

    if (options.typecheck !== "disable") {
      console.error(
        chalk.gray(
          "Trying experimental TypeScript typecheck, remove --typecheck=enable to disable."
        )
      );
    }

    let localConfig: Config;

    if (options.codegen === "disable") {
      console.error(
        chalk.gray("Skipping codegen. Remove --codegen=disable to enable.")
      );
      // Codegen includes typechecking, so if we're skipping it, run the type
      // check manually on the query and mutation functions
      const funcDir = functionsDir(configPath, instanceConfig);
      await processTypeCheckResult(options.typecheck, () =>
        typeCheckFunctions(funcDir)
      );
      localConfig = await configFromInstanceConfig(
        instanceConfig,
        configPath,
        options.verbose
      );
    } else {
      localConfig = await doCodegen({
        instanceConfig,
        configPath,
        adminKey,
        typeCheckMode: options.typecheck,
        dryRun: options.dryRun,
        debug: options.debug,
      });
      console.error(chalk.green("Codegen finished."));
    }

    if (options.debug) {
      const config = configJSON(localConfig, adminKey);
      console.log(JSON.stringify(config));
      return;
    }

    await buildIndexes(
      localConfig.instanceConfig.origin,
      adminKey,
      functionsDir(configPath, localConfig.instanceConfig),
      !!options.dryRun
    );

    const remoteConfig = await pullConfig(origin, adminKey);

    const diff = diffConfig(
      remoteConfig,
      localConfig,
      configPath,
      options.verbose
    );
    if (diff == "") {
      console.log(
        chalk.gray(
          `${
            options.dryRun
              ? "Command would skip function push"
              : "Function push skipped"
          }: Deployment config already synced.`
        )
      );
      return await flushAndExit(0);
    }

    console.log(
      chalk.bold(
        `Remote deployment config ${
          options.dryRun ? "would" : "will"
        } be overwritten with the following changes:`
      )
    );
    console.log(diff);

    if (options.dryRun) {
      return;
    }

    await pushConfig(localConfig, adminKey);
    console.log(chalk.green("Push complete."));
  });
