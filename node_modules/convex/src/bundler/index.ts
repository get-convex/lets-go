import fs from "fs/promises";
import path from "path";
import chalk from "chalk";
import esbuild from "esbuild";

export async function* walkDir(
  dirPath: string
): AsyncGenerator<string, void, void> {
  for await (const dirEntry of await fs.opendir(dirPath)) {
    const childPath = path.join(dirPath, dirEntry.name);
    if (dirEntry.isDirectory()) {
      yield* walkDir(childPath);
    } else if (dirEntry.isFile()) {
      yield childPath;
    }
  }
}

export interface Bundle {
  path: string;
  source: string;
  sourceMap?: string;
}

export class BundleError extends Error {}

async function doEsbuild(
  dir: string,
  entryPoints: string[],
  generateSourceMaps: boolean
): Promise<any> {
  try {
    return await esbuild.build({
      entryPoints,
      bundle: true,
      format: "esm",
      target: "esnext",
      outdir: "out",
      outbase: dir,
      write: false,
      sourcemap: generateSourceMaps,
      splitting: true,
      chunkNames: "_deps/[hash]",
      treeShaking: true,
      minify: false,
    });
  } catch (err) {
    throw new BundleError(`esbuild failed: ${(err as any).toString()}`);
  }
}

export async function bundle(
  dir: string,
  entryPoints: string[],
  generateSourceMaps: boolean
): Promise<Bundle[]> {
  const result = await doEsbuild(dir, entryPoints, generateSourceMaps);
  if (result.errors.length) {
    for (const error of result.errors) {
      console.log(chalk.red(`esbuild error: ${error.text}`));
    }
    throw new BundleError("esbuild failed");
  }
  for (const warning of result.warnings) {
    console.log(chalk.yellow(`esbuild warning: ${warning.text}`));
  }
  const sourceMaps = new Map();
  const modules: Bundle[] = [];
  for (const outputFile of result.outputFiles) {
    const relPath = path.relative(path.normalize("out"), outputFile.path);
    if (path.extname(relPath) === ".map") {
      sourceMaps.set(relPath, outputFile.text);
      continue;
    }
    modules.push({ path: relPath, source: outputFile.text });
  }
  for (const module of modules) {
    const sourceMapPath = module.path + ".map";
    const sourceMap = sourceMaps.get(sourceMapPath);
    if (sourceMap) {
      module.sourceMap = sourceMap;
    }
  }
  return modules;
}

export async function bundleAll(
  dir: string,
  generateSourceMaps: boolean,
  verbose: boolean
): Promise<Bundle[]> {
  const entries = await entryPoints(dir, verbose);
  return bundle(dir, entries, generateSourceMaps);
}

export async function bundleSchema(dir: string) {
  return bundle(dir, [path.resolve(dir, "schema.ts")], true);
}

export async function entryPoints(
  dir: string,
  verbose: boolean
): Promise<string[]> {
  const entryPoints = [];
  for await (const fpath of walkDir(dir)) {
    const relPath = path.relative(dir, fpath);
    const base = path.parse(fpath).base;

    const log = (line: string) => {
      if (verbose) {
        console.log(line);
      }
    };
    if (relPath.startsWith("_deps/")) {
      throw new Error(
        `The path "${fpath}" is within the "_deps" directory, which is reserved for dependencies. Please move your code to another directory.`
      );
    } else if (relPath.startsWith("_generated/")) {
      log(chalk.yellow(`Skipping ${fpath}`));
    } else if (base.startsWith(".")) {
      log(chalk.yellow(`Skipping dotfile ${fpath}`));
    } else if (base === "README.md") {
      log(chalk.yellow(`Skipping ${fpath}`));
    } else if (base === "_generated.ts") {
      log(chalk.yellow(`Skipping ${fpath}`));
    } else if (base === "schema.ts") {
      log(chalk.yellow(`Skipping ${fpath}`));
    } else if (base.includes(".test.")) {
      log(chalk.yellow(`Skipping ${fpath}`));
    } else {
      log(chalk.green(`Preparing ${fpath}`));
      entryPoints.push(fpath);
    }
  }
  return entryPoints;
}
