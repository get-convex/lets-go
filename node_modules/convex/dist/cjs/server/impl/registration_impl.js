"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeQuery = exports.queryGeneric = exports.makeMutation = exports.mutationGeneric = void 0;
const common_1 = require("@convex-dev/common");
const authentication_impl_js_1 = require("./authentication_impl.js");
const database_impl_js_1 = require("./database_impl.js");
function invokeMutation(func, argsStr) {
    return __awaiter(this, void 0, void 0, function* () {
        const args = (0, common_1.jsonToConvex)(JSON.parse(argsStr));
        const mutationCtx = {
            db: (0, database_impl_js_1.setupWriter)(),
            auth: (0, authentication_impl_js_1.setupAuth)(),
        };
        const result = yield Promise.resolve(func(mutationCtx, ...args));
        return JSON.stringify((0, common_1.convexToJson)(result === undefined ? null : result));
    });
}
/**
 * Define a mutation in this Convex app's public API.
 *
 * This function will be allowed to modify your Convex database and will be accessible from the client.
 *
 * If you're using TypeScript, use the `mutation` function in
 * `convex/_generated/server.ts` which is typed for your data model.
 *
 * @param func - The mutation function. It receives a {@link MutationCtx} as its first argument.
 * @returns The wrapped mutation. Include this as an `export` to name it and make it accessible.
 *
 * @public
 */
const mutationGeneric = (func) => {
    const m = func;
    // Helpful runtime check that functions are only be registered once
    if (m.isRegistered) {
        throw new Error("Function registered twice " + func);
    }
    m.isRegistered = true;
    m.isMutation = true;
    m.invokeMutation = argsStr => invokeMutation(func, argsStr);
    return m;
};
exports.mutationGeneric = mutationGeneric;
// Create a `mutation` for a specific `DataModel`.
/**
 * Internal method used by Convex code generation.
 *
 * @public
 */
const makeMutation = () => (func) => {
    return (0, exports.mutationGeneric)(func);
};
exports.makeMutation = makeMutation;
function invokeQuery(func, argsStr) {
    return __awaiter(this, void 0, void 0, function* () {
        const args = (0, common_1.jsonToConvex)(JSON.parse(argsStr));
        const queryCtx = {
            db: (0, database_impl_js_1.setupReader)(),
            auth: (0, authentication_impl_js_1.setupAuth)(),
        };
        const result = yield Promise.resolve(func(queryCtx, ...args));
        return JSON.stringify((0, common_1.convexToJson)(result === undefined ? null : result));
    });
}
/**
 * Define a query in this Convex app's public API.
 *
 * This function will be allowed to read your Convex database and will be accessible from the client.
 *
 * If you're using TypeScript, use the `query` function in
 * `convex/_generated/server.ts` which is typed for your data model.
 *
 * @param func - The query function. It receives a {@link QueryCtx} as its first argument.
 * @returns The wrapped query. Include this as an `export` to name it and make it accessible.
 *
 * @public
 */
const queryGeneric = (func) => {
    const q = func;
    // Helpful runtime check that functions are only be registered once
    if (q.isRegistered) {
        throw new Error("Function registered twice " + func);
    }
    q.isRegistered = true;
    q.isQuery = true;
    q.invokeQuery = argsStr => invokeQuery(func, argsStr);
    return q;
};
exports.queryGeneric = queryGeneric;
// Create a `query` for a specific `DataModel`.
/**
 * Internal method used by Convex code generation.
 *
 * @public
 */
const makeQuery = () => (func) => {
    return (0, exports.queryGeneric)(func);
};
exports.makeQuery = makeQuery;
//# sourceMappingURL=registration_impl.js.map