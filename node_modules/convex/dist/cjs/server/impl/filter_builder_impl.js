"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.filterBuilderImpl = exports.serializeExpression = exports.ExpressionImpl = void 0;
const common_1 = require("@convex-dev/common");
const filter_builder_js_1 = require("../filter_builder.js");
class ExpressionImpl extends filter_builder_js_1.Expression {
    constructor(inner) {
        super();
        this.inner = inner;
    }
    serialize() {
        return this.inner;
    }
}
exports.ExpressionImpl = ExpressionImpl;
function serializeExpression(expr) {
    if (expr instanceof ExpressionImpl) {
        return expr.serialize();
    }
    else {
        // Assume that the expression is a literal Convex value, which we'll serialize
        // to its JSON representation.
        return { $literal: (0, common_1.convexToJson)(expr) };
    }
}
exports.serializeExpression = serializeExpression;
exports.filterBuilderImpl = {
    //  Comparisons  /////////////////////////////////////////////////////////////
    eq(l, r) {
        return new ExpressionImpl({
            $eq: [serializeExpression(l), serializeExpression(r)],
        });
    },
    neq(l, r) {
        return new ExpressionImpl({
            $neq: [serializeExpression(l), serializeExpression(r)],
        });
    },
    lt(l, r) {
        return new ExpressionImpl({
            $lt: [serializeExpression(l), serializeExpression(r)],
        });
    },
    lte(l, r) {
        return new ExpressionImpl({
            $lte: [serializeExpression(l), serializeExpression(r)],
        });
    },
    gt(l, r) {
        return new ExpressionImpl({
            $gt: [serializeExpression(l), serializeExpression(r)],
        });
    },
    gte(l, r) {
        return new ExpressionImpl({
            $gte: [serializeExpression(l), serializeExpression(r)],
        });
    },
    //  Arithmetic  //////////////////////////////////////////////////////////////
    add(l, r) {
        return new ExpressionImpl({
            $add: [serializeExpression(l), serializeExpression(r)],
        });
    },
    sub(l, r) {
        return new ExpressionImpl({
            $sub: [serializeExpression(l), serializeExpression(r)],
        });
    },
    mul(l, r) {
        return new ExpressionImpl({
            $mul: [serializeExpression(l), serializeExpression(r)],
        });
    },
    div(l, r) {
        return new ExpressionImpl({
            $div: [serializeExpression(l), serializeExpression(r)],
        });
    },
    mod(l, r) {
        return new ExpressionImpl({
            $mod: [serializeExpression(l), serializeExpression(r)],
        });
    },
    neg(x) {
        return new ExpressionImpl({ $neg: serializeExpression(x) });
    },
    //  Logic  ///////////////////////////////////////////////////////////////////
    and(...exprs) {
        return new ExpressionImpl({ $and: exprs.map(serializeExpression) });
    },
    or(...exprs) {
        return new ExpressionImpl({ $or: exprs.map(serializeExpression) });
    },
    not(x) {
        return new ExpressionImpl({ $not: serializeExpression(x) });
    },
    //  Other  ///////////////////////////////////////////////////////////////////
    field(fieldPath) {
        return new ExpressionImpl({ $field: fieldPath });
    },
};
//# sourceMappingURL=filter_builder_impl.js.map