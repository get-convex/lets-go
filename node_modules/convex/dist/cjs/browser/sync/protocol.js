"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.serverSchema = exports.queryIdSchema = void 0;
const Base64 = __importStar(require("base64-js"));
const zod_1 = require("zod");
const long_1 = __importDefault(require("long"));
/**
 * Shared schema
 */
// Taken from https://github.com/colinhacks/zod#json-type
const jsonSchema = zod_1.z.lazy(() => zod_1.z.union([
    zod_1.z.string(),
    zod_1.z.number(),
    zod_1.z.boolean(),
    zod_1.z.null(),
    zod_1.z.array(jsonSchema),
    zod_1.z.record(jsonSchema),
]));
const u64Schema = zod_1.z
    .string()
    .refine(arg => Base64.byteLength(arg) == 8)
    .transform(arg => {
    const integerBytes = Base64.toByteArray(arg);
    return long_1.default.fromBytesLE(Array.from(integerBytes), true);
});
/**
 * Validator for {@link QueryId}.
 */
exports.queryIdSchema = zod_1.z.number().int().nonnegative();
const querySetVersionSchema = zod_1.z.number().int().nonnegative();
const mutationIdSchema = zod_1.z.number().int().nonnegative();
const identityVersionSchema = zod_1.z.number().int().nonnegative();
/**
 * Client message schema
 */
const connectSchema = zod_1.z.object({
    type: zod_1.z.literal("Connect"),
    sessionId: zod_1.z.string(),
    connectionCount: zod_1.z.number().int().nonnegative(),
});
const addQuerySchema = zod_1.z.object({
    type: zod_1.z.literal("Add"),
    queryId: exports.queryIdSchema,
    udfPath: zod_1.z.string(),
    args: zod_1.z.array(jsonSchema),
});
const removeQuerySchema = zod_1.z.object({
    type: zod_1.z.literal("Remove"),
    queryId: exports.queryIdSchema,
});
const querySetModificationSchema = zod_1.z.object({
    type: zod_1.z.literal("ModifyQuerySet"),
    baseVersion: querySetVersionSchema,
    newVersion: querySetVersionSchema,
    modifications: zod_1.z.array(zod_1.z.union([addQuerySchema, removeQuerySchema])),
});
const mutationSchema = zod_1.z.object({
    type: zod_1.z.literal("Mutation"),
    mutationId: mutationIdSchema,
    udfPath: zod_1.z.string(),
    args: zod_1.z.array(jsonSchema),
});
const authenticateSchema = zod_1.z.discriminatedUnion("tokenType", [
    zod_1.z.object({
        type: zod_1.z.literal("Authenticate"),
        tokenType: zod_1.z.literal("Admin"),
        value: zod_1.z.string(),
        baseVersion: identityVersionSchema,
    }),
    zod_1.z.object({
        type: zod_1.z.literal("Authenticate"),
        tokenType: zod_1.z.literal("User"),
        value: zod_1.z.string(),
        baseVersion: identityVersionSchema,
    }),
    zod_1.z.object({
        type: zod_1.z.literal("Authenticate"),
        tokenType: zod_1.z.literal("None"),
        baseVersion: identityVersionSchema,
    }),
]);
const clientSchema = zod_1.z.union([
    connectSchema,
    querySetModificationSchema,
    mutationSchema,
    authenticateSchema,
]);
/**
 * Server message schema
 */
const tsSchema = u64Schema;
const logLinesSchema = zod_1.z.array(zod_1.z.string());
const stateVersionSchema = zod_1.z.object({
    querySet: exports.queryIdSchema,
    ts: tsSchema,
    identity: identityVersionSchema,
});
const stateModificationSchema = zod_1.z.discriminatedUnion("type", [
    zod_1.z.object({
        type: zod_1.z.literal("QueryUpdated"),
        queryId: exports.queryIdSchema,
        value: jsonSchema,
        logLines: logLinesSchema,
    }),
    zod_1.z.object({
        type: zod_1.z.literal("QueryFailed"),
        queryId: exports.queryIdSchema,
        errorMessage: zod_1.z.string(),
        logLines: logLinesSchema,
    }),
    zod_1.z.object({
        type: zod_1.z.literal("QueryRemoved"),
        queryId: exports.queryIdSchema,
    }),
]);
const transitionSchema = zod_1.z.object({
    type: zod_1.z.literal("Transition"),
    startVersion: stateVersionSchema,
    endVersion: stateVersionSchema,
    modifications: zod_1.z.array(stateModificationSchema),
});
const mutationSuccessSchema = zod_1.z.object({
    type: zod_1.z.literal("MutationResponse"),
    mutationId: mutationIdSchema,
    success: zod_1.z.literal(true),
    result: jsonSchema,
    ts: tsSchema,
    logLines: logLinesSchema,
});
const mutationFailedSchema = zod_1.z.object({
    type: zod_1.z.literal("MutationResponse"),
    mutationId: mutationIdSchema,
    success: zod_1.z.literal(false),
    result: zod_1.z.string(),
    logLines: logLinesSchema,
});
const mutationResponseSchema = zod_1.z.discriminatedUnion("success", [
    mutationSuccessSchema,
    mutationFailedSchema,
]);
const fatalErrorSchema = zod_1.z.object({
    type: zod_1.z.literal("FatalError"),
    error: zod_1.z.string(),
});
exports.serverSchema = zod_1.z.union([
    transitionSchema,
    mutationResponseSchema,
    fatalErrorSchema,
]);
//# sourceMappingURL=protocol.js.map