"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebSocketManager = void 0;
const protocol_js_1 = require("./protocol.js");
const CLOSE_NORMAL = 1000;
const CLOSE_NO_STATUS = 1005;
function promisePair() {
    let resolvePromise;
    const promise = new Promise(resolve => {
        resolvePromise = resolve;
    });
    return { promise, resolve: resolvePromise };
}
/**
 * A wrapper around a websocket that handles errors, reconnection, and message
 * parsing.
 */
class WebSocketManager {
    constructor(uri, onOpen, onMessage, webSocketConstructor) {
        this.webSocketConstructor = webSocketConstructor;
        this.socket = { state: "disconnected" };
        this.initialBackoff = 100;
        this.maxBackoff = 16000;
        this.retries = 0;
        this.closedUnexpectedly = false;
        this.uri = uri;
        this.onOpen = onOpen;
        this.onMessage = onMessage;
        this.connect();
    }
    connect() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.socket.state === "closing" ||
                this.socket.state === "stopping" ||
                this.socket.state === "stopped") {
                return;
            }
            if (this.socket.state !== "disconnected") {
                throw new Error("Didn't start connection from disconnected state");
            }
            const ws = new this.webSocketConstructor(this.uri);
            this.socket = {
                state: "connecting",
                ws,
            };
            ws.onopen = () => {
                if (this.socket.state !== "connecting") {
                    throw new Error("onopen called with socket not in connecting state");
                }
                this.socket = { state: "ready", ws };
                if (!this.closedUnexpectedly) {
                    this.retries = 0;
                }
                this.onOpen();
            };
            // NB: The WebSocket API calls `onclose` even if connection fails, so we can route all error paths through `onclose`.
            ws.onerror = error => {
                const message = error.message;
                console.log(`WebSocket error: ${message}`);
                this.closeAndReconnect();
            };
            ws.onmessage = message => {
                if (this.closedUnexpectedly) {
                    this.closedUnexpectedly = false;
                    this.retries = 0;
                }
                try {
                    const serverMessage = protocol_js_1.serverSchema.parse(JSON.parse(message.data));
                    this.onMessage(serverMessage);
                }
                catch (error) {
                    console.log(`Failed to process server message, reconnecting: ${error}`);
                    this.closeAndReconnect();
                    throw error;
                }
            };
            ws.onclose = event => {
                if (event.code !== CLOSE_NORMAL && event.code !== CLOSE_NO_STATUS) {
                    let msg = `WebSocket closed unexpectedly with code ${event.code}`;
                    if (event.reason) {
                        msg += `: ${event.reason}`;
                    }
                    console.error(msg);
                    this.closedUnexpectedly = true;
                }
                if (this.socket.state === "stopping") {
                    this.socket.promisePair.resolve(null);
                    this.socket = { state: "stopped" };
                    return;
                }
                this.socket = { state: "disconnected" };
                const backoff = this.nextBackoff();
                console.log(`Attempting reconnect in ${backoff}ms`);
                setTimeout(() => this.connect(), backoff);
            };
        });
    }
    sendMessage(message) {
        if (this.socket.state === "ready") {
            const request = JSON.stringify(message);
            try {
                this.socket.ws.send(request);
            }
            catch (error) {
                console.log(`Failed to send message on WebSocket, reconnecting: ${error}`);
                this.closeAndReconnect();
            }
        }
    }
    /**
     * Close the WebSocket and schedule a reconnect when it completes closing.
     *
     * This should be used when we hit an error and would like to restart the session.
     */
    closeAndReconnect() {
        switch (this.socket.state) {
            case "disconnected":
            case "closing":
            case "stopping":
            case "stopped":
                // Nothing to do if we don't have a WebSocket.
                return;
            case "connecting":
            case "ready":
                this.socket.ws.close();
                this.socket = {
                    state: "closing",
                };
                return;
            default: {
                // Enforce that the switch-case is exhaustive.
                // eslint-disable-next-line  @typescript-eslint/no-unused-vars
                const _ = this.socket;
            }
        }
    }
    /**
     * Close the WebSocket and never reconnect.
     * @returns A Promise that resolves when the WebSocket `onClose` callback is called.
     */
    stop() {
        return __awaiter(this, void 0, void 0, function* () {
            switch (this.socket.state) {
                case "stopped":
                    return;
                case "connecting":
                case "ready":
                    this.socket.ws.close();
                    this.socket = {
                        state: "stopping",
                        promisePair: promisePair(),
                    };
                    yield this.socket.promisePair.promise;
                    return;
                case "closing":
                    // We're already closing the WebSocket, so just upgrade the state
                    // to "stopping" so we don't reconnect.
                    this.socket = {
                        state: "stopping",
                        promisePair: promisePair(),
                    };
                    yield this.socket.promisePair.promise;
                    return;
                case "disconnected":
                    // We're disconnected so switch the state to "stopped" so the reconnect
                    // timeout doesn't create a new WebSocket.
                    this.socket = { state: "stopped" };
                    return;
                case "stopping":
                    yield this.socket.promisePair.promise;
                    return;
                default: {
                    // Enforce that the switch-case is exhaustive.
                    // eslint-disable-next-line  @typescript-eslint/no-unused-vars
                    const _ = this.socket;
                }
            }
        });
    }
    nextBackoff() {
        const baseBackoff = this.initialBackoff * Math.pow(2, this.retries);
        this.retries += 1;
        const actualBackoff = Math.min(baseBackoff, this.maxBackoff);
        const jitter = actualBackoff * (Math.random() - 0.5);
        return actualBackoff + jitter;
    }
}
exports.WebSocketManager = WebSocketManager;
//# sourceMappingURL=web_socket_manager.js.map