"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.InternalConvexClient = void 0;
const index_js_1 = require("../../index.js");
const local_state_js_1 = require("./local_state.js");
const mutation_manager_js_1 = require("./mutation_manager.js");
const optimistic_query_set_js_1 = require("./optimistic_query_set.js");
const remote_query_set_js_1 = require("./remote_query_set.js");
const udf_path_utils_js_1 = require("./udf_path_utils.js");
const web_socket_manager_js_1 = require("./web_socket_manager.js");
const uuid_1 = require("uuid");
const logging_js_1 = require("../logging.js");
const DEFAULT_OPTIONS = {
    unsavedChangesWarning: true,
};
/**
 * Low-level client for directly integrating state management libraries
 * with Convex.
 *
 * Most developers should use higher level clients, like
 * the {@link ConvexHttpClient} or the React hook based {@link react.ConvexReactClient}.
 *
 * @public
 */
class InternalConvexClient {
    /**
     * @param address - The url of your Convex deployment, typically from the
     * `origin` property of a convex.json config file.
     * E.g. `https://small-mouse-123.convex.cloud`.
     * @param onTransition - A callback receiving an array of serialized queries,
     * called each time updated query results are received from the Convex cloud.
     * @param options - See {@link ClientOptions} for a full description.
     */
    constructor(address, onTransition, options) {
        options = Object.assign(Object.assign({}, DEFAULT_OPTIONS), options);
        let webSocketConstructor = options.webSocketConstructor;
        if (!webSocketConstructor && typeof WebSocket === "undefined") {
            throw new Error("No WebSocket global variable defined! To use Convex in an environment without WebSocket try the HTTP client: https://docs.convex.dev/api/classes/browser.ConvexHttpClient");
        }
        webSocketConstructor = webSocketConstructor || WebSocket;
        // Substitute http(s) with ws(s)
        const i = address.search("://");
        if (i == -1) {
            throw new Error("Provided address was not an absolute URL.");
        }
        const origin = address.substring(i + 3); // move past the double slash
        const protocol = address.substring(0, i);
        let wsProtocol;
        if (protocol === "http") {
            wsProtocol = "ws";
        }
        else if (protocol === "https") {
            wsProtocol = "wss";
        }
        else {
            throw new Error(`Unknown parent protocol ${protocol}`);
        }
        const wsUri = `${wsProtocol}://${origin}/api/${index_js_1.version}/sync`;
        this.state = new local_state_js_1.LocalSyncState();
        this.remoteQuerySet = new remote_query_set_js_1.RemoteQuerySet(queryId => this.state.queryPath(queryId));
        this.mutationManager = new mutation_manager_js_1.MutationManager();
        this.optimisticQueryResults = new optimistic_query_set_js_1.OptimisticQueryResults();
        this.onTransition = onTransition;
        this.nextMutationId = 0;
        this.sessionId = (0, uuid_1.v4)();
        this.connectionCount = 0;
        const { unsavedChangesWarning } = options;
        if (typeof window === "undefined" && unsavedChangesWarning) {
            throw new Error("unsavedChangesWarning enabled, but no window object found! Navigating away from the page could cause in-flight mutations to be dropped. Pass {unsavedChangesWarning: false} in Convex client options to disable this feature.");
        }
        // Listen for tab close events and notify the user on unsaved changes.
        unsavedChangesWarning &&
            window.addEventListener("beforeunload", e => {
                if (this.mutationManager.hasUncommittedMutations()) {
                    // There are 3 different ways to trigger this pop up so just try all of
                    // them.
                    e.preventDefault();
                    // This confirmation message doesn't actually appear in most modern
                    // browsers but we tried.
                    const confirmationMessage = "Are you sure you want to leave? Your changes may not be saved.";
                    (e || window.event).returnValue = confirmationMessage;
                    return confirmationMessage;
                }
            });
        this.webSocketManager = new web_socket_manager_js_1.WebSocketManager(wsUri, () => {
            // We have a new WebSocket!
            this.webSocketManager.sendMessage({
                type: "Connect",
                sessionId: this.sessionId,
                connectionCount: this.connectionCount,
            });
            this.connectionCount += 1;
            // Throw out our remote query, reissue queries
            // and outstanding mutations, and reauthenticate.
            this.remoteQuerySet = new remote_query_set_js_1.RemoteQuerySet(queryId => this.state.queryPath(queryId));
            const [querySetModification, authModification] = this.state.restart();
            if (authModification) {
                this.webSocketManager.sendMessage(authModification);
            }
            this.webSocketManager.sendMessage(querySetModification);
            for (const message of this.mutationManager.restart()) {
                this.webSocketManager.sendMessage(message);
            }
        }, (serverMessage) => {
            if (serverMessage.type == "Transition") {
                this.remoteQuerySet.transition(serverMessage);
                const completedMutations = this.mutationManager.removeCompletedMutations(this.remoteQuerySet.timestamp());
                this.notifyOnQueryResultChanges(completedMutations);
            }
            else if (serverMessage.type == "MutationResponse") {
                const completedMutationId = this.mutationManager.onResponse(serverMessage);
                if (completedMutationId) {
                    this.notifyOnQueryResultChanges(new Set([completedMutationId]));
                }
            }
            else if (serverMessage.type == "FatalError") {
                const error = (0, logging_js_1.logFatalError)(serverMessage.error);
                this.webSocketManager.stop();
                throw error;
            }
        }, webSocketConstructor);
    }
    /**
     * Compute the current query results based on the remoteQuerySet and the
     * current optimistic updates and call `onTransition` for all the changed
     * queries.
     *
     * @param completedMutations - A set of mutation IDs whose optimistic updates
     * are no longer needed.
     */
    notifyOnQueryResultChanges(completedMutations) {
        const remoteQueryResults = this.remoteQuerySet.remoteQueryResults();
        const queryTokenToValue = new Map();
        for (const [queryId, result] of remoteQueryResults) {
            const queryToken = this.state.queryToken(queryId);
            // It's possible that we've already unsubscribed to this query but
            // the server hasn't learned about that yet. If so, ignore this one.
            if (queryToken !== null) {
                const query = {
                    result,
                    udfPath: this.state.queryPath(queryId),
                    args: this.state.queryArgs(queryId),
                };
                queryTokenToValue.set(queryToken, query);
            }
        }
        this.onTransition(this.optimisticQueryResults.ingestQueryResultsFromServer(queryTokenToValue, completedMutations));
    }
    setAuth(value) {
        const message = this.state.setAuth(value);
        this.webSocketManager.sendMessage(message);
    }
    /** @internal */
    setAdminAuth(value) {
        const message = this.state.setAdminAuth(value);
        this.webSocketManager.sendMessage(message);
    }
    clearAuth() {
        const message = this.state.clearAuth();
        this.webSocketManager.sendMessage(message);
    }
    subscribe(udfPath, args) {
        const { modification, queryToken, unsubscribe } = this.state.subscribe(udfPath, args);
        if (modification !== null) {
            this.webSocketManager.sendMessage(modification);
        }
        // TODO: Use FinalizationRegistry?
        return {
            queryToken,
            unsubscribe: () => {
                const modification = unsubscribe();
                if (modification) {
                    this.webSocketManager.sendMessage(modification);
                }
            },
        };
    }
    /**
     * A query result based only on the current, local state.
     *
     * The only way this will return a value is if we're already subscribed to the
     * query or its value has been set optimistically.
     */
    localQueryResult(udfPath, args) {
        const queryToken = (0, udf_path_utils_js_1.serializePathAndArgs)(udfPath, args);
        return this.optimisticQueryResults.queryResult(queryToken);
    }
    mutate(udfPath, args, optimisticUpdate = null) {
        return __awaiter(this, void 0, void 0, function* () {
            const mutationId = this.nextMutationId;
            this.nextMutationId++;
            if (optimisticUpdate !== null) {
                const wrappedUpdate = (localQueryStore) => {
                    optimisticUpdate(localQueryStore, ...args);
                };
                const changedQueries = this.optimisticQueryResults.applyOptimisticUpdate(wrappedUpdate, mutationId);
                this.onTransition(changedQueries);
            }
            const { message, result } = this.mutationManager.request(udfPath, args, mutationId);
            this.webSocketManager.sendMessage(message);
            return result;
        });
    }
    close() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.webSocketManager.stop();
        });
    }
}
exports.InternalConvexClient = InternalConvexClient;
//# sourceMappingURL=client.js.map