import { ClientMessage, ServerMessage } from "./protocol.js";
/**
 * A wrapper around a websocket that handles errors, reconnection, and message
 * parsing.
 */
export declare class WebSocketManager {
    private socket;
    /** Upon HTTPS/WSS failure, the first jittered backoff duration, in ms. */
    private readonly initialBackoff;
    /** We backoff exponentially, but we need to cap that--this is the jittered max. */
    private readonly maxBackoff;
    /** How many times have we failed consecutively? */
    private retries;
    /** Did the WebSocket close unexpectedly? If so, we won't consider the socket
     * healthy until we receive a successful message from the server: Initiating
     * the connection won't be sufficient. */
    private closedUnexpectedly;
    private readonly uri;
    private readonly onOpen;
    private readonly onMessage;
    private readonly webSocketConstructor;
    constructor(uri: string, onOpen: () => void, onMessage: (message: ServerMessage) => void, webSocketConstructor: typeof WebSocket);
    private connect;
    sendMessage(message: ClientMessage): void;
    /**
     * Close the WebSocket and schedule a reconnect when it completes closing.
     *
     * This should be used when we hit an error and would like to restart the session.
     */
    private closeAndReconnect;
    /**
     * Close the WebSocket and never reconnect.
     * @returns A Promise that resolves when the WebSocket `onClose` callback is called.
     */
    stop(): Promise<void>;
    private nextBackoff;
}
//# sourceMappingURL=web_socket_manager.d.ts.map