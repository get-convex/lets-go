/**
 * Utilities for defining the schema of your Convex project.
 *
 * ## Usage
 *
 * Schemas should be placed in a `schema.ts` file in your `convex/` directory.
 *
 * Schema definitions should be built using {@link defineSchema},
 * {@link defineTable}, and {@link s}. Make sure to export the schema as the
 * default export.
 *
 * ```ts
 * import { defineSchema, defineTable, s } from "convex/schema";
 *
 *  export default defineSchema({
 *    messages: defineTable({
 *      body: s.string(),
 *      time: s.number(),
 *      user: s.id(),
 *    }),
 *    users: defineTable({
 *      name: s.string(),
 *    }),
 *  });
 * ```
 *
 * To learn more about schemas, see [Defining a Schema](https://docs.convex.dev/using/schemas).
 * @module
 */
import { Id } from "@convex-dev/common";
import { GenericDocument, GenericTableIndexes } from "../server/data_model.js";
/**
 * A Convex type defined in a schema.
 *
 * These should be constructed using {@link s}.
 *
 * This type encapsulates both:
 * - The TypeScript type that represents this Convex type.
 * - The set of index field paths that can be used to build indexes on this type.
 * @public
 */
export declare type SchemaType<TypeScriptType, FieldPaths extends string> = {
    type: TypeScriptType;
    fieldPaths: FieldPaths;
    _isSchemaType: undefined;
};
/**
 * The schema builder.
 *
 * This builder allows you to define the types of documents stored in Convex.
 * @public
 */
export declare const s: {
    id(): SchemaType<Id, never>;
    null(): SchemaType<null, never>;
    number(): SchemaType<number, never>;
    bigint(): SchemaType<bigint, never>;
    boolean(): SchemaType<boolean, never>;
    string(): SchemaType<string, never>;
    bytes(): SchemaType<ArrayBuffer, never>;
    array<T>(values: SchemaType<T, any>): SchemaType<T[], never>;
    set<T_1>(values: SchemaType<T_1, any>): SchemaType<Set<T_1>, never>;
    map<K, V>(keys: SchemaType<K, any>, values: SchemaType<V, any>): SchemaType<Map<K, V>, never>;
    object<T_2 extends Record<string, SchemaType<any, any>>>(schema: T_2): ObjectSchemaType<T_2>;
    union<T_3 extends [SchemaType<any, any>, SchemaType<any, any>, ...SchemaType<any, any>[]]>(...schemaTypes: T_3): UnionSchemaType<T_3>;
};
/**
 * Calculate the {@link SchemaType} for a union.
 *
 * This is used in the SchemaBuilder {@link s}.
 * @public
 */
declare type UnionSchemaType<SchemaValueType extends SchemaType<any, any>[]> = SchemaValueType extends SchemaType<infer InnerType, infer FieldPathsType>[] ? SchemaType<InnerType, FieldPathsType> : never;
/**
 * Calculate the {@link SchemaType} for an object.
 *
 * This is used within the SchemaBuilder {@link s}.
 * @public
 */
declare type ObjectSchemaType<SchemaValueType extends Record<string, SchemaType<any, any>>> = SchemaType<{
    [Property in keyof SchemaValueType]: SchemaValueType[Property] extends SchemaType<infer InnerType, any> ? InnerType : never;
}, FieldPathsInObject<SchemaValueType>>;
/**
 * Join together two index field paths.
 *
 * This is used within the SchemaBuilder {@link s}.
 * @public
 */
declare type JoinFieldPaths<Start extends string, End extends string> = `${Start}.${End}`;
/**
 * Calculate all of the index field paths in an object {@link SchemaType}.
 *
 * This is used within the SchemaBuilder {@link s}.
 * @public
 */
declare type FieldPathsInObject<ObjectType extends Record<string, SchemaType<any, any>>> = {
    [Property in keyof ObjectType]: ObjectType[Property] extends SchemaType<any, infer FieldPaths> ? JoinFieldPaths<Property & string, FieldPaths> | Property : never;
}[keyof ObjectType] & string;
/**
 * Add a property and value onto a TypeScript object type.
 *
 * If the property is present in the object already that field will be
 * overwritten.
 *
 * This is similar to `ObjectType & {PropertyName: Value}` but TypeScript
 * doesn't simplify intersections so in practice this creates cleaner types.
 *
 * @public
 */
declare type AddPropertyToObjectType<ObjectType extends Record<string, any>, PropertyName extends string, Value> = {
    [Property in PropertyName | keyof ObjectType]: Property extends PropertyName ? Value : ObjectType[Property];
};
/**
 * Extract all of the index field paths within a {@link SchemaType}.
 *
 * This is used within {@link defineTable}.
 * @public
 */
declare type ExtractFieldPaths<T extends SchemaType<any, any>> = T extends SchemaType<any, infer FieldPaths> ? FieldPaths : never;
/**
 * Extract the {@link GenericDocument} within a {@link SchemaType} and
 * add on the `_id` field.
 *
 * This is used within {@link defineTable}.
 * @public
 */
declare type ExtractDocument<T extends SchemaType<any, any>> = T extends SchemaType<infer Value, any> ? Value extends Record<string, any> ? AddPropertyToObjectType<Value, "_id", Id> & GenericDocument : never : never;
/**
 * The definition of a table within a schema.
 *
 * This should be produced by using {@link defineTable}.
 * @public
 */
export declare class TableDefinition<Document extends GenericDocument = GenericDocument, FieldPaths extends string = string, TableIndexes extends GenericTableIndexes = {}> {
    private indexes;
    /**
     * @internal
     */
    constructor();
    /**
     * Define an index on this table.
     *
     * To learn about indexes, see [Defining Indexes](https://docs.convex.dev/using/indexes).
     *
     * @param name - The name of the index.
     * @param fields - The fields to index, in order. Must specify at least one
     * field.
     * @returns A {@link TableDefinition} with this index included.
     */
    index<IndexName extends string, FirstFieldPath extends FieldPaths, RestFieldPaths extends FieldPaths[]>(name: IndexName, fields: [FirstFieldPath, ...RestFieldPaths]): TableDefinition<Document, FieldPaths, AddPropertyToObjectType<TableIndexes, IndexName, [
        FirstFieldPath,
        ...RestFieldPaths
    ]>>;
    /**
     * Export the contents of this definition.
     *
     * This is called internally by the Convex framework.
     * @internal
     */
    export(): {
        indexDescriptor: string;
        fields: string[];
    }[];
}
/**
 * Define a table in a schema.
 *
 * You can either specify the schema of your documents as an object like
 * ```ts
 * defineTable({
 *   field: b.string()
 * });
 * ```
 *
 * or as a schema type like
 * ```ts
 * defineTable(b.object({
 *   field: b.string()
 * }));
 * ```
 *
 * @param documentSchema - The type of documents stored in this table.
 * @returns A {@link TableDefinition} for the table.
 *
 * @public
 */
export declare function defineTable<DocumentSchema extends SchemaType<Record<string, any>, any>>(documentSchema: DocumentSchema): TableDefinition<ExtractDocument<DocumentSchema>, ExtractFieldPaths<DocumentSchema>>;
/**
 * Define a table in a schema.
 *
 * You can either specify the schema of your documents as an object like
 * ```ts
 * defineTable({
 *   field: b.string()
 * });
 * ```
 *
 * or as a schema type like
 * ```ts
 * defineTable(b.object({
 *   field: b.string()
 * }));
 * ```
 *
 * @param documentSchema - The type of documents stored in this table.
 * @returns A {@link TableDefinition} for the table.
 *
 * @public
 */
export declare function defineTable<DocumentSchema extends Record<string, SchemaType<any, any>>>(documentSchema: DocumentSchema): TableDefinition<ExtractDocument<ObjectSchemaType<DocumentSchema>>, ExtractFieldPaths<ObjectSchemaType<DocumentSchema>>>;
/**
 * A type describing the schema of a Convex project.
 *
 * This should be constructed using {@link defineSchema}, {@link defineTable},
 * and {@link s}.
 * @public
 */
export declare type GenericSchema = Record<string, TableDefinition>;
/**
 *
 * The definition of a Convex project schema.
 *
 * This should be produced by using {@link defineSchema}.
 * @public
 */
export declare class SchemaDefinition<Schema extends GenericSchema> {
    private tables;
    /**
     * @internal
     */
    constructor(tables: Schema);
    /**
     * Export the contents of this definition.
     *
     * This is called internally by the Convex framework.
     * @internal
     */
    export(): string;
}
/**
 * Define the schema of this Convex project.
 *
 * This should be exported from a `schema.ts` file in your `convex/` directory
 * like:
 *
 * ```ts
 * export default defineSchema({
 *   ...
 * });
 * ```
 *
 * @param schema - A map from table name to {@link TableDefinition} for all of
 * the tables in this project.
 * @returns The schema.
 *
 * @public
 */
export declare function defineSchema<Schema extends GenericSchema>(schema: Schema): SchemaDefinition<Schema>;
export {};
//# sourceMappingURL=index.d.ts.map