"use strict";
/**
 * Tools to integrate Convex into React applications.
 *
 * This module contains:
 * 1. {@link ConvexReactClient}, a client for using Convex in React.
 * 2. {@link ConvexProvider}, a component that stores this client in React context.
 * 2. [Hooks](https://docs.convex.dev/generated-api/react#react-hooks) for calling into
 *    this client within your React components.
 *
 * ## Usage
 *
 * ### Creating the Client
 *
 * ```typescript
 * import { ConvexReactClient } from "convex/react";
 * import convexConfig from "../convex.json";
 *
 * const convex = new ConvexReactClient(convexConfig.origin);
 * ```
 *
 * ### Storing the Client In React Context
 *
 * ```typescript
 * import { ConvexProvider } from "convex/react";
 *
 * <ConvexProvider client={convex}>
 *   <App />
 * </ConvexProvider>
 * ```
 *
 * ### Generating the Hooks
 *
 * This module is typically used alongside generated TypeScript hooks.
 *
 * To generate the hooks, run `npx convex codegen` in your Convex project. This
 * will create a `convex/_generated/react.ts` file with the following React
 * hooks, typed for your queries and mutations:
 * - [useQuery](https://docs.convex.dev/generated-api/react#usequery)
 * - [useMutation](https://docs.convex.dev/generated-api/react#usemutation)
 * - [useConvex](https://docs.convex.dev/generated-api/react#useconvex)
 *
 * If you aren't using TypeScript and code generation, you can use these untyped
 * hooks instead:
 * - {@link useQueryGeneric}
 * - {@link useMutationGeneric}
 * - {@link useConvexGeneric}
 *
 * ### Using the Hooks
 *
 * ```typescript
 * import { useQuery, useMutation } from "../convex/_generated/react";
 *
 * function App() {
 *   const counter = useQuery("getCounter");
 *   const increment = useMutation("incrementCounter");
 *   // Your component here!
 * }
 * ```
 * @module
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeUseConvex = exports.makeUseMutation = exports.makeUseQuery = exports.useMutationGeneric = exports.useQueryGeneric = exports.ConvexProvider = exports.useConvexGeneric = exports.ConvexReactClient = void 0;
const index_js_1 = require("../browser/index.js");
const react_1 = __importStar(require("react"));
const common_1 = require("@convex-dev/common");
const react_dom_1 = __importDefault(require("react-dom"));
const use_subscription_js_1 = require("./use_subscription.js");
// TODO add runtime check that React version is good too.
if (typeof react_1.default === "undefined") {
    throw new Error("Required dependency 'react' not installed");
}
if (typeof react_dom_1.default === "undefined") {
    throw new Error("Required dependency 'react-dom' not installed");
}
function createMutation(name, sync, update = null) {
    function mutation(...args) {
        return sync().mutate(name, args, update);
    }
    mutation.withOptimisticUpdate = function withOptimisticUpdate(optimisticUpdate) {
        if (update !== null) {
            throw new Error(`Already specified optimistic update for mutation ${name}`);
        }
        return createMutation(name, sync, optimisticUpdate);
    };
    return mutation;
}
const DEFAULT_OPTIONS = {
    unsavedChangesWarning: true,
};
/**
 * A Convex client for use within React.
 *
 * This loads reactive queries and executes mutations over a WebSocket.
 *
 * @typeParam API - The API of your application, composed of all Convex queries
 * and mutations. `npx convex codegen` [generates this type](/generated-api/react#convexapi)
 * in `convex/_generated/react.ts`.
 * @public
 */
class ConvexReactClient {
    /**
     * @param address - The url of your Convex deployment, typically from the `origin` property of a convex.json config file, E.g. `https://small-mouse-123.convex.cloud`.
     * @param options - See {@link ReactClientOptions} for a full description.
     */
    constructor(address, options) {
        this.address = address;
        this.listeners = new Map();
        this.options = Object.assign(Object.assign({}, DEFAULT_OPTIONS), options);
    }
    /**
     * Lazily instantiate the `InternalConvexClient` so we don't create the WebSocket
     * when server-side rendering.
     */
    get sync() {
        if (this.cachedSync) {
            return this.cachedSync;
        }
        this.cachedSync = new index_js_1.InternalConvexClient(this.address, updatedQueries => this.transition(updatedQueries), this.options);
        if (this.adminAuth) {
            this.cachedSync.setAdminAuth(this.adminAuth);
        }
        return this.cachedSync;
    }
    /**
     * Set the authentication token to be used for subsequent queries and mutations.
     * Should be called whenever the token changes (i.e. due to expiration and refresh)
     * @param token - JWT-encoded OpenID Connect Identity Token
     */
    setAuth(token) {
        this.sync.setAuth(token);
    }
    /**
     * Clear the current authentication token if set.
     */
    clearAuth() {
        this.sync.clearAuth();
    }
    /**
     * @internal
     */
    setAdminAuth(token) {
        this.adminAuth = token;
        if (this.cachedSync) {
            this.sync.setAdminAuth(token);
        }
    }
    /**
     * Construct a new {@link Watch} on a Convex query function.
     *
     * **Most application code should not call this method directly. Instead use
     * the `useQuery` hook generated by `npx convex codegen`.**
     *
     * @param name - The name of the query function.
     * @param args - The arguments to the query.
     * @returns The {@link Watch} object.
     */
    watchQuery(name, ...args) {
        return {
            onUpdate: callback => {
                const { queryToken, unsubscribe } = this.sync.subscribe(name, args);
                const currentListeners = this.listeners.get(queryToken);
                if (currentListeners !== undefined) {
                    currentListeners.add(callback);
                }
                else {
                    this.listeners.set(queryToken, new Set([callback]));
                }
                return () => {
                    const currentListeners = this.listeners.get(queryToken);
                    currentListeners.delete(callback);
                    if (currentListeners.size == 0) {
                        this.listeners.delete(queryToken);
                    }
                    unsubscribe();
                };
            },
            localQueryResult: () => {
                // Use the cached client because we can't have a query result if we don't
                // even have a client yet!
                if (this.cachedSync) {
                    return this.cachedSync.localQueryResult(name, args);
                }
                return undefined;
            },
        };
    }
    /**
     * Construct a new {@link ReactMutation}.
     *
     * @param name - The name of the Mutation.
     * @returns The {@link ReactMutation} object with that name.
     */
    mutation(name) {
        // this cast can be removed in TypeScript 4.6
        return createMutation(name, () => this.sync);
    }
    /**
     * Close any network handles associated with this client.
     *
     * Call this method when you're done with a {@link ConvexReactClient} to
     * dispose of its sockets and resources.
     *
     * @returns A `Promise` fulfilled when the connection has been completely closed.
     */
    close() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.cachedSync) {
                const sync = this.cachedSync;
                this.cachedSync = undefined;
                yield sync.close();
            }
        });
    }
    transition(updatedQueries) {
        react_dom_1.default.unstable_batchedUpdates(() => {
            for (const queryToken of updatedQueries) {
                const callbacks = this.listeners.get(queryToken);
                if (callbacks) {
                    for (const callback of callbacks) {
                        callback();
                    }
                }
            }
        });
    }
}
exports.ConvexReactClient = ConvexReactClient;
const ConvexContext = react_1.default.createContext(undefined // in the future this will be a mocked client for testing
);
/**
 * Get the {@link ConvexReactClient} within a React component.
 *
 * This relies on the {@link ConvexProvider} being above in the React component tree.
 *
 * If you're using TypeScript, use the `useConvex` function in
 * `convex/_generated/react.ts` which is typed for your API.
 *
 * @returns The active {@link ConvexReactClient} object, or `undefined`.
 *
 * @public
 */
function useConvexGeneric() {
    return (0, react_1.useContext)(ConvexContext);
}
exports.useConvexGeneric = useConvexGeneric;
/**
 * Provides an active Convex {@link ConvexReactClient} to descendants of this component.
 *
 * Wrap your app in this component to use Convex hooks `useQuery`,
 * `useMutation`, and `useConvex`.
 *
 * @param props - an object with a `client` property that refers to a {@link ConvexReactClient}.
 *
 * @public
 */
const ConvexProvider = ({ client, children }) => {
    return react_1.default.createElement(ConvexContext.Provider, { value: client }, children);
};
exports.ConvexProvider = ConvexProvider;
/**
 * Load a reactive query within a React component.
 *
 * This React hook contains internal state that will cause a rerender
 * whenever the query result changes.
 *
 * Throws an error if not used under {@link ConvexProvider}.
 *
 * If you're using TypeScript, use the `useQuery` function in
 * `convex/_generated/react.ts` which is typed for your API.
 *
 * @param name - The name of the query function.
 * @param args - The arguments to the query function.
 * @returns `undefined` if loading and the query's return value otherwise.
 *
 * @public
 */
function useQueryGeneric(name, ...args) {
    const convex = (0, react_1.useContext)(ConvexContext);
    if (convex === undefined) {
        throw new Error("Could not find Convex client! `useQuery` must be used in the React component " +
            "tree under `ConvexProvider`. Did you forget it? " +
            "See https://docs.convex.dev/quick-start#set-up-convex-in-your-react-app");
    }
    const subscription = (0, react_1.useMemo)(() => {
        const watch = convex.watchQuery(name, ...args);
        return {
            getCurrentValue: () => watch.localQueryResult(),
            subscribe: (callback) => watch.onUpdate(callback),
        };
    }, 
    // ESLint doesn't like that we're stringifying the args. We do this because
    // we want to avoid recreating the subscription if the args are a different
    // object that serializes to the same result.
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [name, convex, JSON.stringify((0, common_1.convexToJson)(args))]);
    const queryResult = (0, use_subscription_js_1.useSubscription)(subscription);
    return queryResult;
}
exports.useQueryGeneric = useQueryGeneric;
/**
 * Construct a new {@link ReactMutation}.
 *
 * Mutation objects can be called like functions to request execution of the
 * corresponding Convex function, or further configured with
 * [optimistic updates](https://docs.convex.dev/using/optimistic-updates).
 *
 * The value returned by this hook is stable across renders, so it can be used
 * by React dependency arrays and memoization logic relying on object identity
 * without causing rerenders.
 *
 * If using TypeScript, prefer the `useMutation` function imported
 * from `convex/_generated/react.ts` which is typed for your API.
 *
 * Throws an error if not used under {@link ConvexProvider}.
 *
 * @param name - The name of the mutation.
 * @returns The {@link ReactMutation} object with that name.
 *
 * @public
 */
function useMutationGeneric(name) {
    const convex = (0, react_1.useContext)(ConvexContext);
    if (convex === undefined) {
        throw new Error("Could not find Convex client! `useMutation` must be used in the React component " +
            "tree under `ConvexProvider`. Did you forget it? " +
            "See https://docs.convex.dev/quick-start#set-up-convex-in-your-react-app");
    }
    return (0, react_1.useMemo)(() => convex.mutation(name), [convex, name]);
}
exports.useMutationGeneric = useMutationGeneric;
// Create a useQuery for a specific API.
// Intended only for use by the typed client code generated by the Convex CLI.
/**
 * Internal method used by Convex code generation.
 *
 * @public
 */
const makeUseQuery = () => (name, ...args) => {
    return useQueryGeneric(name, ...args);
};
exports.makeUseQuery = makeUseQuery;
// Create a useMutation for a specific API
// Intended only for use by the typed client code generated by the Convex CLI.
/**
 * Internal method used by Convex code generation.
 *
 * @public
 */
const makeUseMutation = () => (name) => {
    return useMutationGeneric(name);
};
exports.makeUseMutation = makeUseMutation;
// Creates a useConvex for a specific API
// Intended for use by the typed client code generated by the Convex CLI.
/**
 * Internal method used by Convex code generation.
 *
 * @public
 */
const makeUseConvex = () => () => {
    const convex = useConvexGeneric();
    return convex;
};
exports.makeUseConvex = makeUseConvex;
//# sourceMappingURL=index.js.map