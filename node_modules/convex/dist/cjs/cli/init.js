"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.optins = exports.init = void 0;
const axios_1 = __importDefault(require("axios"));
const commander_1 = require("commander");
const chalk_1 = __importDefault(require("chalk"));
const fs_1 = __importDefault(require("fs"));
const config_js_1 = require("./config.js");
const index_js_1 = require("../index.js");
const utils_js_1 = require("./utils.js");
const inquirer_1 = __importDefault(require("inquirer"));
const ora_1 = __importDefault(require("ora"));
const path_1 = require("path");
const codegen_js_1 = require("./codegen.js");
/** Initialize a new Convex deployment. */
exports.init = new commander_1.Command("init")
    .description("Initialize a new Convex deployment in the current directory")
    .addOption(utils_js_1.BETA_KEY_OPTION)
    .option("--deployment-type <type>", "Type of deployment to create (`convex.<type>.json`). Defaults to `convex.json`")
    .action((options) => __awaiter(void 0, void 0, void 0, function* () {
    if (options.betaKey) {
        console.error(chalk_1.default.yellow(utils_js_1.BETA_KEY_DEPRECATION_MESSAGE));
    }
    const authHeader = yield (0, utils_js_1.getAuthHeader)();
    const name = (0, config_js_1.configName)(options.deploymentType);
    const configPath = yield (0, config_js_1.configFilepath)(name);
    if (yield (0, utils_js_1.exists)(configPath)) {
        const deploymentTypeFlag = options.deploymentType != undefined
            ? ` --deployment-type=${options.deploymentType}`
            : "";
        console.error(chalk_1.default.red(`Deployment "${configPath}" already exists.`));
        console.error(`Use \`convex push${deploymentTypeFlag}\` to apply changes to the existing deployment.`);
        console.error(`Use \`convex deactivate${deploymentTypeFlag}\` to deactivate the existing deployment and reclaim a deployment towards your deployment quota.`);
        console.error();
        console.error("Use `convex init --deployment-type={type}` to create an additional deployment.");
        console.error("- Eg: `convex init --deployment-type=dev`");
        return yield (0, utils_js_1.flushAndExit)(1);
    }
    const existingConfig = fs_1.default
        .readdirSync((0, path_1.dirname)(configPath))
        .find(e => e.match("^convex.*.json$"));
    let existingInstanceName;
    if (existingConfig != undefined) {
        const matches = existingConfig.match("^convex.(.*).json$");
        const existingDeployment = matches && matches[1];
        const { instanceConfig } = yield (0, config_js_1.readInstanceConfig)(existingDeployment);
        existingInstanceName = instanceConfig.instanceName;
    }
    const envFn = (0, config_js_1.envFilename)(options.deploymentType);
    const env = yield (0, config_js_1.readEnv)(options.deploymentType);
    if (env != null) {
        console.error(chalk_1.default.red(`File "${envFn}" already exists.`));
        console.error("Remove this file to create a new project.");
        return yield (0, utils_js_1.flushAndExit)(1);
    }
    // Do opt in to TOS and Privacy Policy stuff first.
    const shouldContinue = yield optins(options.betaKey, authHeader);
    if (!shouldContinue) {
        return yield (0, utils_js_1.flushAndExit)(1);
    }
    const spinner = (0, ora_1.default)({
        text: "Creating new Convex deployment...\n",
        stream: process.stdout,
    }).start();
    const { instanceOrigin, adminKey, redemptionsRemaining } = yield provision(authHeader, options.betaKey, existingInstanceName, options.deploymentType);
    const { instanceConfig, modules } = yield (0, config_js_1.pullConfig)(instanceOrigin, adminKey);
    spinner.succeed(`Successfully deployed ${instanceOrigin}`);
    if (modules.length > 0) {
        console.error(chalk_1.default.red("Error: Unexpected modules in new project"));
        return yield (0, utils_js_1.flushAndExit)(1);
    }
    yield (0, config_js_1.writeAdminKey)(options.deploymentType, adminKey);
    yield (0, config_js_1.writeInstanceConfig)(options.deploymentType, instanceConfig);
    console.log(chalk_1.default.green(`Done! Your account now has ${redemptionsRemaining} deployments remaining.`));
    {
        const { instanceConfig, configPath } = yield (0, config_js_1.readInstanceConfig)(options.deploymentType);
        yield (0, codegen_js_1.doCodegen)({
            instanceConfig,
            configPath,
            adminKey,
            // Don't typecheck because there isn't any code to check yet.
            typeCheckMode: "disable",
            // Schema files will always be missing initially so skip the warning this
            // time.
            warnOnMissingSchemaFile: false,
        });
    }
    console.log(chalk_1.default.bold.red("\nConvex is an early beta product and provides no reliability guarantees!"));
    console.log("Please don't use the current version of Convex for any mission-critical applications.");
    console.log(chalk_1.default.bold("\nWe would love feedback at either:"));
    console.log("- https://convex.dev/slack");
    console.log("- support@convex.dev\n");
    console.log("Configuration settings have been written to", chalk_1.default.bold(configPath));
    console.log("The admin key was written to", chalk_1.default.bold(envFn));
    console.log("See documentation at", chalk_1.default.bold("https://docs.convex.dev"), "for next steps.");
}));
/** Provision a new empty deployment and return the origin. */
function provision(authHeader, betaKey, existingInstanceName, deployment) {
    return __awaiter(this, void 0, void 0, function* () {
        const headers = authHeader
            ? { Authorization: authHeader }
            : {};
        const provisioningArgs = {
            betaKey,
            existingInstanceName,
            deployment,
            backendVersionOverride: process.env.CONVEX_BACKEND_VERSION_OVERRIDE,
        };
        const provisionUrl = `${config_js_1.provisionHost}/api/${index_js_1.version}/provision`;
        const client = axios_1.default.create();
        try {
            const res = yield client.post(provisionUrl, provisioningArgs, {
                headers,
            });
            (0, utils_js_1.deprecationCheck)(res);
            const instanceOrigin = res.data.url;
            const instanceName = res.data.instanceName;
            const adminKey = res.data.adminKey;
            const redemptionsRemaining = res.data.redemptionsRemaining;
            if (adminKey === undefined ||
                instanceOrigin === undefined ||
                redemptionsRemaining === undefined) {
                const msg = "Unknown error during provisioning: " + JSON.stringify(res.data);
                console.error(chalk_1.default.red(msg));
                return yield (0, utils_js_1.flushAndExit)(1, new Error(msg));
            }
            return { instanceName, instanceOrigin, adminKey, redemptionsRemaining };
        }
        catch (err) {
            console.error(chalk_1.default.red("Error: Unable to provision deployment"));
            (0, utils_js_1.printServerErr)(err);
            return yield (0, utils_js_1.flushAndExit)(1, err);
        }
    });
}
// Returns whether we can proceed or not.
function optins(betaKey, authHeader) {
    return __awaiter(this, void 0, void 0, function* () {
        const headers = authHeader
            ? { Authorization: authHeader }
            : {};
        const checkOptInsUrl = `${config_js_1.provisionHost}/api/${index_js_1.version}/check_opt_ins`;
        const client = axios_1.default.create();
        let res;
        try {
            const args = { betaKey };
            res = (yield client.post(checkOptInsUrl, args, { headers })).data;
        }
        catch (err) {
            (0, utils_js_1.printServerErr)(err);
            return Promise.resolve(false);
        }
        if (res.optInsToAccept.length == 0) {
            return Promise.resolve(true);
        }
        for (const optInToAccept of res.optInsToAccept) {
            const confirmed = (yield inquirer_1.default.prompt([
                {
                    type: "confirm",
                    name: "confirmed",
                    message: optInToAccept.message,
                },
            ])).confirmed;
            if (!confirmed) {
                console.log("Please accept the Terms of Service to use Convex.");
                return Promise.resolve(false);
            }
        }
        const optInsAccepted = res.optInsToAccept.map(o => o.optIn);
        const args = { betaKey, optInsAccepted };
        const acceptOptInsUrl = `${config_js_1.provisionHost}/api/${index_js_1.version}/accept_opt_ins`;
        try {
            yield client.post(acceptOptInsUrl, args, { headers });
        }
        catch (err) {
            (0, utils_js_1.printServerErr)(err);
            return Promise.resolve(false);
        }
        return Promise.resolve(true);
    });
}
exports.optins = optins;
//# sourceMappingURL=init.js.map