"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.doTypeCheck = exports.typeCheckFunctions = exports.processTypeCheckResult = exports.typecheck = void 0;
const child_process_1 = __importDefault(require("child_process"));
const chalk_1 = __importDefault(require("chalk"));
const utils_1 = require("./utils");
const bundler_1 = require("../bundler");
const commander_1 = require("commander");
const config_1 = require("./config");
/** Run the TypeScript compiler, as configured during  */
exports.typecheck = new commander_1.Command("typecheck")
    .description("Run TypeScript typechecking on your Convex functions with `tsc --noEmit`.")
    .action(() => __awaiter(void 0, void 0, void 0, function* () {
    const { configPath, config: localConfig } = yield (0, config_1.readConfig)(null, false);
    const typecheckResult = yield typeCheckFunctions((0, utils_1.functionsDir)(configPath, localConfig.instanceConfig));
    if (typecheckResult === "cantTypeCheck" ||
        typecheckResult === "typecheckFailed") {
        console.error(chalk_1.default.gray("Typecheck failed"));
        return yield (0, utils_1.flushAndExit)(1);
    }
    else {
        console.error(chalk_1.default.green("Typecheck passed: `tsc --noEmit` completed with exit code 0."));
        return yield (0, utils_1.flushAndExit)(0);
    }
}));
/**
 * Conditionally run a typecheck function and interpret the result.
 *
 * If typeCheckMode === "disable", never run the typecheck function.
 * If typeCheckMode === "enable", run the typecheck and crash if typechecking
 * fails or we can't find tsc.
 * If typeCheckMode === "try", try and run the typecheck. crash if typechecking
 * fails but don't worry if tsc is missing and we can't run it.
 */
function processTypeCheckResult(typeCheckMode, runTypeCheck) {
    return __awaiter(this, void 0, void 0, function* () {
        if (typeCheckMode === "disable") {
            return;
        }
        const result = yield runTypeCheck();
        if ((result === "cantTypeCheck" && typeCheckMode === "enable") ||
            result === "typecheckFailed") {
            console.error(chalk_1.default.gray("To ignore failing typecheck, use `--typecheck=disable`."));
            return yield (0, utils_1.flushAndExit)(1);
        }
    });
}
exports.processTypeCheckResult = processTypeCheckResult;
// Runs TypeScript compiler to typecheck Convex query and mutation functions.
function typeCheckFunctions(functionsDir) {
    return __awaiter(this, void 0, void 0, function* () {
        const toCheck = yield (0, bundler_1.entryPoints)(functionsDir, false);
        return doTypeCheck(toCheck);
    });
}
exports.typeCheckFunctions = typeCheckFunctions;
function doTypeCheck(entryPoints) {
    return __awaiter(this, void 0, void 0, function* () {
        // usually there's a node_modules/.bin in this directory
        if (!(yield (0, utils_1.exists)("node_modules/.bin/tsc"))) {
            console.error(`Can't find TypeScript compiler \`tsc\` to use to typecheck Convex functions.`);
            // give up; there are lots of other ways to run TypeScript,
            // plus maybe the user isn't using TypeScript.
            return "cantTypeCheck";
        }
        // TODO try to override tsconfig? Examine nearest tsconfig? use a custom tsconfig?
        // suggest that users
        try {
            // In the future, we'll want to create a temp tsconfig here that inherits
            // from the first ancestor directory with a tsconfig.json as described in
            // https://github.com/microsoft/TypeScript/issues/27379
            child_process_1.default.execFileSync("node_modules/.bin/tsc", [
                ...entryPoints,
                "--noEmit",
                "--esModuleInterop",
                "--allowJs", // just a guess!
            ], { stdio: "inherit" });
        }
        catch (e) {
            console.error(chalk_1.default.red("TypeScript typecheck via `tsc` failed."));
            return "typecheckFailed";
        }
        return "success";
    });
}
exports.doTypeCheck = doTypeCheck;
//# sourceMappingURL=typecheck.js.map