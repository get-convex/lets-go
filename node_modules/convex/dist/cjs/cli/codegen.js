"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.doCodegen = exports.codegen = void 0;
const axios_1 = __importDefault(require("axios"));
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const prettier_1 = __importDefault(require("prettier"));
const commander_1 = require("commander");
const config_js_1 = require("./config.js");
const chalk_1 = __importDefault(require("chalk"));
const utils_js_1 = require("./utils.js");
const index_js_1 = require("../index.js");
const common_1 = require("@convex-dev/common");
const react_js_1 = require("./codegen_templates/react.js");
const dataModel_js_1 = require("./codegen_templates/dataModel.js");
const server_js_1 = require("./codegen_templates/server.js");
const typecheck_js_1 = require("./typecheck.js");
exports.codegen = new commander_1.Command("codegen")
    .description("Generate a client for the current contents of the convex/ directory")
    .option("-v, --verbose", "Show full listing of changes")
    .option("--dry-run", "Print out the generated configuration to stdout instead of writing to convex directory")
    .addOption(new commander_1.Option("--debug").hideHelp())
    .addOption(new commander_1.Option("--typecheck <mode>", `Whether to check TypeScript files with \`tsc --noEmit\`.`)
    .choices(["enable", "try", "disable"])
    .default("disable"))
    .action((options) => __awaiter(void 0, void 0, void 0, function* () {
    const adminKey = (yield (0, config_js_1.mustReadEnv)(options.deploymentType)).adminKey;
    const { instanceConfig, configPath } = yield (0, config_js_1.readInstanceConfig)(options.deploymentType);
    yield (0, utils_js_1.pkgVersionConsistencyCheck)(instanceConfig.origin);
    if (options.typecheck !== "disable") {
        console.error(chalk_1.default.gray("Trying experimental TypeScript typecheck, remove --typecheck=enable to disable."));
    }
    yield doCodegen({
        instanceConfig,
        configPath,
        adminKey,
        typeCheckMode: options.typecheck,
        dryRun: options.dryRun,
        debug: options.debug,
        verbose: options.verbose,
    });
    chalk_1.default.green("Codegen finished.");
}));
/**
 * Computes all the query and mutation functions defined in the convex/
 * directory by shipping the bundled source to the backend.
 */
function determineFunctions(config, adminKey) {
    return __awaiter(this, void 0, void 0, function* () {
        const serializedConfig = (0, config_js_1.configJSON)(config, adminKey);
        try {
            const res = yield axios_1.default.post(`${config.instanceConfig.origin}/api/${index_js_1.version}/analyze_config`, serializedConfig);
            (0, utils_js_1.deprecationCheck)(res);
            return (0, common_1.jsonToConvex)(res.data);
        }
        catch (err) {
            console.error(chalk_1.default.red("Error: Unable to determine Convex functions", config.instanceConfig.origin));
            (0, utils_js_1.printServerErr)(err);
            return yield (0, utils_js_1.flushAndExit)(1, err);
        }
    });
}
/**
 * Run prettier so we don't have to think about formatting!
 *
 * This is a little sketchy because we are using the default prettier config
 * (not our user's one) but it's better than nothing.
 */
function format(source) {
    return prettier_1.default.format(source, { parser: "typescript" });
}
function writeFile(filename, source, codegenDir, dryRun, debug) {
    const formattedSource = format(source);
    const dest = path_1.default.join(codegenDir, filename);
    if (debug) {
        console.log(`# ${dest}`);
        console.log(formattedSource);
        return;
    }
    if (dryRun) {
        if (fs_1.default.existsSync(dest)) {
            const fileText = fs_1.default.readFileSync(dest, "utf8");
            if (fileText !== formattedSource) {
                console.log(`Command would replace file: ${dest}`);
            }
        }
        else {
            console.log(`Command would create file: ${dest}`);
        }
        return;
    }
    console.log(`writing ${dest}`);
    fs_1.default.writeFileSync(dest, formattedSource, "utf8");
}
function doServerCodegen(codegenDir, dryRun, hasSchemaFile, debug) {
    if (hasSchemaFile) {
        writeFile("dataModel.ts", (0, dataModel_js_1.dataModelCodegen)(), codegenDir, dryRun, debug);
    }
    else {
        writeFile("dataModel.ts", (0, dataModel_js_1.dataModelCodegenWithoutSchema)(), codegenDir, dryRun, debug);
    }
    writeFile("server.ts", (0, server_js_1.serverCodegen)(), codegenDir, dryRun, debug);
}
function doReactCodegen(config, adminKey, codegenDir, dryRun, debug) {
    return __awaiter(this, void 0, void 0, function* () {
        const { modules } = yield determineFunctions(config, adminKey);
        const udfs = [];
        const filenames = [...modules.keys()].sort();
        for (const filename of filenames) {
            const udfsInModule = (0, utils_js_1.sorted)(modules.get(filename).functions, udf => udf.name);
            for (const udf of udfsInModule) {
                udfs.push({
                    filename,
                    name: udf.name,
                    isQuery: udf.isQuery,
                    isMutation: udf.isMutation,
                });
            }
        }
        writeFile("react.ts", (0, react_js_1.reactCodegen)(udfs), codegenDir, dryRun, debug);
    });
}
function doCodegen({ instanceConfig, configPath, adminKey, typeCheckMode, dryRun = false, verbose = false, warnOnMissingSchemaFile = true, debug = false, }) {
    return __awaiter(this, void 0, void 0, function* () {
        const funcDir = (0, utils_js_1.functionsDir)(configPath, instanceConfig);
        // Delete the old _generated.ts because v0.1.2 used to put the react generated
        // code there
        const legacyCodegenPath = path_1.default.join(funcDir, "_generated.ts");
        if (fs_1.default.existsSync(legacyCodegenPath)) {
            if (!dryRun) {
                console.log(`Deleting legacy codegen file: ${legacyCodegenPath}}`);
                fs_1.default.rmSync(legacyCodegenPath);
            }
            else {
                console.log(`Command would delete legacy codegen file: ${legacyCodegenPath}}`);
            }
        }
        // Create the codegen dir if it doesn't already exist.
        const codegenDir = path_1.default.join(funcDir, "_generated");
        if (!fs_1.default.existsSync(codegenDir)) {
            fs_1.default.mkdirSync(codegenDir);
        }
        const schemaPath = path_1.default.join(funcDir, "schema.ts");
        const hasSchemaFile = fs_1.default.existsSync(schemaPath);
        if (warnOnMissingSchemaFile && !hasSchemaFile) {
            console.warn(chalk_1.default.yellow(`Did not find a schema file at \`${schemaPath}\`. The generated code will consider documents to have the \`any\` type. To add a schema see https://docs.convex.dev/using/schemas`));
        }
        // Do things in a careful order so that we always:
        // - typecheck sources before we use them.
        // - generate code in dependency order.
        //
        // The dependency chain is:
        // _generated/react.ts
        // -> query and mutation functions
        // -> _generated/server.ts
        // -> schema.ts
        // (where -> means "depends on")
        // 1. Typecheck the schema.ts file
        if (hasSchemaFile) {
            yield (0, typecheck_js_1.processTypeCheckResult)(typeCheckMode, () => (0, typecheck_js_1.doTypeCheck)([path_1.default.join(funcDir, "schema.ts")]));
        }
        // 2. Use the schema.ts file to create the server codegen
        doServerCodegen(codegenDir, dryRun, hasSchemaFile, debug);
        // 3. Typecheck the query and mutation functions
        yield (0, typecheck_js_1.processTypeCheckResult)(typeCheckMode, () => (0, typecheck_js_1.typeCheckFunctions)(funcDir));
        // 4. Bundle the query and mutation functions
        const config = yield (0, config_js_1.configFromInstanceConfig)(instanceConfig, configPath, verbose);
        // 5. Generate the React code
        yield doReactCodegen(config, adminKey, codegenDir, dryRun, debug);
        // Return the config so other code won't bundle twice.
        return config;
    });
}
exports.doCodegen = doCodegen;
//# sourceMappingURL=codegen.js.map