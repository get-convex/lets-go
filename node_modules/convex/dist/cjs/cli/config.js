"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.diffConfig = exports.pushConfig = exports.configJSON = exports.pullConfig = exports.writeAdminKey = exports.writeInstanceConfig = exports.writeReadme = exports.readEnv = exports.envFilename = exports.mustReadEnv = exports.readConfig = exports.configFromInstanceConfig = exports.readInstanceConfig = exports.configFilepath = exports.configName = exports.parseConfig = exports.provisionHost = exports.productionProvisionHost = void 0;
const chalk_1 = __importDefault(require("chalk"));
const promises_1 = __importDefault(require("fs/promises"));
const axios_1 = __importDefault(require("axios"));
const deep_equal_1 = __importDefault(require("deep-equal"));
const path_1 = __importDefault(require("path"));
const index_js_1 = require("../bundler/index.js");
const index_js_2 = require("../index.js");
const envfile_1 = require("envfile");
const axios_retry_1 = __importDefault(require("axios-retry"));
const utils_js_1 = require("./utils.js");
exports.productionProvisionHost = "https://provision.convex.dev";
exports.provisionHost = process.env.CONVEX_PROVISION_HOST || exports.productionProvisionHost;
/** Check if object is of AuthInfo type. */
function isAuthInfo(object) {
    return ("applicationID" in object &&
        typeof object.applicationID === "string" &&
        "domain" in object &&
        typeof object.domain === "string");
}
function isAuthInfos(object) {
    return Array.isArray(object) && object.every((item) => isAuthInfo(item));
}
/** Error parsing InstanceConfig representation. */
class ParseError extends Error {
}
/** Parse object to InstanceConfig. */
function parseConfig(obj) {
    var _a;
    if (typeof obj !== "object") {
        throw new ParseError("Expected an object");
    }
    if (typeof obj.origin !== "string") {
        throw new ParseError("Expected origin to be a string");
    }
    if (obj.instanceName && typeof obj.instanceName !== "string") {
        throw new ParseError("Expected deployment name to be a string");
    }
    if (typeof obj.functions !== "string") {
        throw new ParseError("Expected functions to be a string");
    }
    // Allow the `authInfo` key to be omitted, treating it as an empty list of providers.
    obj.authInfo = (_a = obj.authInfo) !== null && _a !== void 0 ? _a : [];
    if (!isAuthInfos(obj.authInfo)) {
        throw new ParseError("Expected authInfo to be type AuthInfo[]");
    }
    // Important! We return the object itself (not a new object) because
    // we want to ensure that fields we're unaware of are "passed through".
    // It's possible that this is an old client and the server knows about new
    // fields that we don't.
    return obj;
}
exports.parseConfig = parseConfig;
function configName(deployment) {
    if (deployment == null) {
        return "convex.json";
    }
    else {
        if (deployment == "") {
            throw new Error("Can't have empty string for deployment");
        }
        return `convex.${deployment}.json`;
    }
}
exports.configName = configName;
function configFilepath(configFn) {
    return __awaiter(this, void 0, void 0, function* () {
        const packages = yield (0, utils_js_1.loadPackageJson)();
        const isCreateReactApp = !!packages.filter(({ name }) => name === "react-scripts").length;
        // create-react-app (aka react-scripts) requires all src files be in src/
        // so prefer src/convex.json on init.
        const standardLocation = configFn;
        const srcLocation = path_1.default.join("src", configFn);
        const [preferredLocation, wrongLocation] = isCreateReactApp
            ? [srcLocation, standardLocation]
            : [standardLocation, srcLocation];
        // Allow either location, but not both.
        const standardLocationExists = yield (0, utils_js_1.exists)(standardLocation);
        const srcLocationExists = yield (0, utils_js_1.exists)(srcLocation);
        if (standardLocationExists && srcLocationExists) {
            console.error(chalk_1.default.red(`Error: both ${preferredLocation} and ${wrongLocation} files exist!`));
            console.error(`Consolidate these and remove ${wrongLocation}.`);
            return yield (0, utils_js_1.flushAndExit)(1);
        }
        if (preferredLocation === standardLocation) {
            return preferredLocation;
        }
        try {
            yield promises_1.default.access("src");
        }
        catch (e) {
            console.error(chalk_1.default.red(`Error: use of create-react-app detected (found react-scripts in package.json) but no src directory found.`));
            return yield (0, utils_js_1.flushAndExit)(1);
        }
        return preferredLocation;
    });
}
exports.configFilepath = configFilepath;
/** Read configuration from a local `convex.json` file. */
function readInstanceConfig(deployment) {
    return __awaiter(this, void 0, void 0, function* () {
        let instanceConfig;
        const configFn = configName(deployment);
        const configPath = yield configFilepath(configFn);
        try {
            instanceConfig = parseConfig(JSON.parse(yield promises_1.default.readFile(configPath, { encoding: "utf-8" })));
        }
        catch (err) {
            if (err instanceof ParseError || err instanceof SyntaxError) {
                console.error(chalk_1.default.red(`Error: Parsing "${configPath}" failed`));
                console.error(chalk_1.default.gray(err.toString()));
            }
            else {
                console.error(chalk_1.default.red(`Error: Unable to read deployment config file "${configPath}"`));
                console.error("Are you running this command from the root directory of a Convex app?");
                if (err instanceof Error) {
                    console.error(chalk_1.default.gray(err.message));
                }
            }
            return yield (0, utils_js_1.flushAndExit)(1, err);
        }
        return {
            instanceConfig,
            configPath,
        };
    });
}
exports.readInstanceConfig = readInstanceConfig;
/**
 * Given an {@link InstanceConfig}, add in the bundled modules to produce the
 * complete config.
 */
function configFromInstanceConfig(instanceConfig, configPath, verbose) {
    return __awaiter(this, void 0, void 0, function* () {
        let modules;
        try {
            modules = yield (0, index_js_1.bundleAll)((0, utils_js_1.functionsDir)(configPath, instanceConfig), true, verbose);
        }
        catch (err) {
            console.error(chalk_1.default.red("Error: Unable to bundle Convex modules"));
            if (err instanceof Error) {
                console.error(chalk_1.default.gray(err.message));
            }
            return yield (0, utils_js_1.flushAndExit)(1, err);
        }
        return {
            instanceConfig: instanceConfig,
            modules: modules,
            // We're just using the version this CLI is running with for now.
            // This could be different than the version of `convex` the app runs with
            // if the CLI is installed globally.
            udfServerVersion: index_js_2.version,
        };
    });
}
exports.configFromInstanceConfig = configFromInstanceConfig;
/**
 * Read the config from `convex.json` and bundle all the modules.
 */
function readConfig(deployment, verbose) {
    return __awaiter(this, void 0, void 0, function* () {
        const { instanceConfig, configPath } = yield readInstanceConfig(deployment);
        const config = yield configFromInstanceConfig(instanceConfig, configPath, verbose);
        return { config, configPath };
    });
}
exports.readConfig = readConfig;
function mustReadEnv(deployment) {
    return __awaiter(this, void 0, void 0, function* () {
        const envFn = envFilename(deployment);
        const env = yield readEnv(deployment);
        if (env != null) {
            return env;
        }
        try {
            yield promises_1.default.access("convex.json");
        }
        catch (err) {
            console.error("Are you running this command from the root directory of an initialized Convex app? We couldn't find your convex.json");
            return yield (0, utils_js_1.flushAndExit)(1);
        }
        console.error(chalk_1.default.red(`Error: Unable to find the CONVEX_ADMIN_KEY environment variable.\nHave you set your CONVEX_ADMIN_KEY in "${envFn}" or in your environment variables?`));
        console.error("");
        console.error("  CONVEX_ADMIN_KEY=<your deployment's admin key>");
        console.error("");
        return yield (0, utils_js_1.flushAndExit)(1);
    });
}
exports.mustReadEnv = mustReadEnv;
function envFilename(deployment) {
    if (deployment == null) {
        return ".env.local";
    }
    else {
        if (deployment == "") {
            throw new Error("Can't have empty string for deployment");
        }
        return `.env.${deployment}.local`;
    }
}
exports.envFilename = envFilename;
function readEnv(deployment) {
    return __awaiter(this, void 0, void 0, function* () {
        if (process.env.CONVEX_ADMIN_KEY) {
            return { adminKey: process.env.CONVEX_ADMIN_KEY };
        }
        let envContents;
        try {
            envContents = yield promises_1.default.readFile(envFilename(deployment), {
                encoding: "utf-8",
            });
        }
        catch (err) {
            return null;
        }
        const envFile = (0, envfile_1.parse)(envContents);
        const adminKey = envFile["CONVEX_ADMIN_KEY"];
        if (!adminKey || adminKey == "undefined") {
            return null;
        }
        return { adminKey };
    });
}
exports.readEnv = readEnv;
/** Write a README file in `{config/functions}/README.md` */
function writeReadme(functionsDir) {
    return __awaiter(this, void 0, void 0, function* () {
        const readmeFileName = "README.md";
        const readmeUrl = `${exports.provisionHost}/api/${index_js_2.version}/readme/`;
        const client = axios_1.default.create();
        return client.get(readmeUrl).then((res) => __awaiter(this, void 0, void 0, function* () {
            const readme = res.data.readme;
            let readmeFile;
            try {
                readmeFile = yield promises_1.default.open(functionsDir + readmeFileName, "w", 0o644);
            }
            catch (err) {
                console.error(chalk_1.default.red('Error: Unable to open file "README.md" for writing in "' +
                    functionsDir +
                    '"'));
                console.error("Are you running this command from the root directory of a Convex app?");
                return yield (0, utils_js_1.flushAndExit)(1);
            }
            try {
                yield readmeFile.writeFile(readme + "\n");
            }
            catch (err) {
                return yield (0, utils_js_1.flushAndExit)(1, err);
            }
            finally {
                readmeFile.close();
            }
        }));
    });
}
exports.writeReadme = writeReadme;
/** Write the config to `convex.json` in the current working directory. */
function writeInstanceConfig(deployment, instanceConfig) {
    return __awaiter(this, void 0, void 0, function* () {
        const configFn = configName(deployment);
        const configPath = yield configFilepath(configFn);
        let configFile;
        try {
            configFile = yield promises_1.default.open(configPath, "w", 0o644);
        }
        catch (err) {
            console.error(chalk_1.default.red(`Error: Unable to open deployment config file "${configPath}" for writing in current directory`));
            console.error("Are you running this command from the root directory of a Convex app?");
            return yield (0, utils_js_1.flushAndExit)(1);
        }
        try {
            yield configFile.writeFile(JSON.stringify(instanceConfig, undefined, 2) + "\n");
        }
        catch (err) {
            console.error(chalk_1.default.red(`Error: Unable to write deployment config file "${configPath}"`));
            return yield (0, utils_js_1.flushAndExit)(1, err);
        }
        finally {
            configFile.close();
        }
        try {
            yield promises_1.default.mkdir((0, utils_js_1.functionsDir)(configPath, instanceConfig));
        }
        catch (err) {
            // skipping error
        }
        yield writeReadme((0, utils_js_1.functionsDir)(configPath, instanceConfig));
    });
}
exports.writeInstanceConfig = writeInstanceConfig;
function writeAdminKey(deployment, adminKey) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!adminKey) {
            console.error(chalk_1.default.red(`Error: unexpected - admin key is missing`));
            return yield (0, utils_js_1.flushAndExit)(1);
        }
        const envFn = envFilename(deployment);
        let envLocalFile;
        try {
            envLocalFile = yield promises_1.default.open(envFn, "w", 0o644);
        }
        catch (err) {
            console.error(chalk_1.default.red(`Error: Unable to open file "${envFn}" in current directory`));
            console.error("Are you running this command from the root directory of a Convex app?");
            return yield (0, utils_js_1.flushAndExit)(1);
        }
        try {
            yield envLocalFile.writeFile(`CONVEX_ADMIN_KEY=${adminKey}\n`);
        }
        catch (err) {
            console.error(chalk_1.default.red(`Error: Unable to write file "${envFilename}" in current directory`));
            return yield (0, utils_js_1.flushAndExit)(1, err);
        }
        finally {
            envLocalFile.close();
        }
    });
}
exports.writeAdminKey = writeAdminKey;
/** Pull configuration from the given remote origin. */
function pullConfig(origin, adminKey) {
    return __awaiter(this, void 0, void 0, function* () {
        const client = axios_1.default.create();
        (0, axios_retry_1.default)(client, {
            retries: 4,
            retryDelay: axios_retry_1.default.exponentialDelay,
            retryCondition: error => {
                var _a;
                return ((_a = error.response) === null || _a === void 0 ? void 0 : _a.status) == 404 || false;
            },
        });
        try {
            const res = yield client.post(`${origin}/api/${index_js_2.version}/get_config`, { version: index_js_2.version, adminKey }, {
                maxContentLength: Infinity,
            });
            (0, utils_js_1.deprecationCheck)(res);
            return {
                instanceConfig: parseConfig(res.data.config),
                modules: res.data.modules,
                udfServerVersion: res.data.udfServerVersion,
            };
        }
        catch (err) {
            console.error(chalk_1.default.red("Error: Unable to pull deployment config from", origin));
            (0, utils_js_1.printServerErr)(err);
            return yield (0, utils_js_1.flushAndExit)(1, err);
        }
    });
}
exports.pullConfig = pullConfig;
function configJSON(config, adminKey) {
    return {
        // TODO: Remove this since it's being passed up in the URL.
        version: index_js_2.version,
        config: config.instanceConfig,
        modules: config.modules,
        udfServerVersion: config.udfServerVersion,
        adminKey,
    };
}
exports.configJSON = configJSON;
/** Push configuration to the given remote origin. */
function pushConfig(config, adminKey) {
    return __awaiter(this, void 0, void 0, function* () {
        const serializedConfig = configJSON(config, adminKey);
        const origin = config.instanceConfig.origin;
        try {
            yield axios_1.default.post(`${origin}/api/${index_js_2.version}/push_config`, serializedConfig, {
                maxContentLength: Infinity,
                maxBodyLength: Infinity,
            });
        }
        catch (err) {
            console.error(chalk_1.default.red("Error: Unable to push deployment config to", origin));
            (0, utils_js_1.printServerErr)(err);
            return yield (0, utils_js_1.flushAndExit)(1, err);
        }
    });
}
exports.pushConfig = pushConfig;
// We can eventually switch to something like `filesize` for i18n and
// more robust formatting, but let's keep our CLI bundle small for now.
function formatSize(n) {
    if (n < 1024) {
        return `${n} B`;
    }
    if (n < 1024 * 1024) {
        return `${Math.floor(n / 1024)} KB`;
    }
    if (n < 1024 * 1024 * 1024) {
        return `${Math.floor(n / 1024 / 1024)} MB`;
    }
    return `${n} B`;
}
function isDepsPath(modulePath) {
    return modulePath.startsWith("_deps/");
}
function renderModule(functions, module, verbose) {
    var _a, _b;
    const relPath = path_1.default.join(functions, module.path);
    if (verbose) {
        const sourceMapSize = formatSize((_b = (_a = module.sourceMap) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0);
        return (relPath +
            ` (${formatSize(module.source.length)}, source map ${sourceMapSize})`);
    }
    return relPath;
}
/** Generate a human-readable diff between the two configs. */
function diffConfig(oldConfig, newConfig, configPath, verbose) {
    let diff = "";
    const droppedModules = [];
    for (const oldModule of oldConfig.modules) {
        let matches = false;
        for (const newModule of newConfig.modules) {
            const oldPath = path_1.default.join(oldConfig.instanceConfig.functions, oldModule.path);
            const newPath = path_1.default.join(newConfig.instanceConfig.functions, newModule.path);
            if (oldPath === newPath &&
                oldModule.source === newModule.source &&
                oldModule.sourceMap === newModule.sourceMap) {
                matches = true;
                break;
            }
        }
        if (!matches) {
            if (!isDepsPath(oldModule.path) || verbose) {
                droppedModules.push(oldModule);
            }
        }
    }
    if (droppedModules.length > 0) {
        diff += "Delete the following modules:\n";
        for (const module of droppedModules) {
            diff +=
                "[-] " +
                    renderModule((0, utils_js_1.functionsDir)(configPath, oldConfig.instanceConfig), module, verbose) +
                    "\n";
        }
    }
    const addedModules = [];
    for (const newModule of newConfig.modules) {
        let matches = false;
        for (const oldModule of oldConfig.modules) {
            const oldPath = path_1.default.join(oldConfig.instanceConfig.functions, oldModule.path);
            const newPath = path_1.default.join(newConfig.instanceConfig.functions, newModule.path);
            if (oldPath === newPath &&
                oldModule.source === newModule.source &&
                oldModule.sourceMap === newModule.sourceMap) {
                matches = true;
                break;
            }
        }
        if (!matches) {
            if (!isDepsPath(newModule.path) || verbose) {
                addedModules.push(newModule);
            }
        }
    }
    if (addedModules.length > 0) {
        diff += "Add the following modules:\n";
        for (const module of addedModules) {
            diff +=
                "[+] " +
                    renderModule((0, utils_js_1.functionsDir)(configPath, newConfig.instanceConfig), module, verbose) +
                    "\n";
        }
    }
    const droppedAuth = [];
    for (const oldAuth of oldConfig.instanceConfig.authInfo) {
        let matches = false;
        for (const newAuth of newConfig.instanceConfig.authInfo) {
            if ((0, deep_equal_1.default)(oldAuth, newAuth)) {
                matches = true;
                break;
            }
        }
        if (!matches) {
            droppedAuth.push(oldAuth);
        }
    }
    if (droppedAuth.length > 0) {
        diff += "Remove the following auth providers:\n";
        for (const authInfo of droppedAuth) {
            diff += "[-] " + JSON.stringify(authInfo) + "\n";
        }
    }
    const addedAuth = [];
    for (const newAuth of newConfig.instanceConfig.authInfo) {
        let matches = false;
        for (const oldAuth of oldConfig.instanceConfig.authInfo) {
            if ((0, deep_equal_1.default)(newAuth, oldAuth)) {
                matches = true;
                break;
            }
        }
        if (!matches) {
            addedAuth.push(newAuth);
        }
    }
    if (addedAuth.length > 0) {
        diff += "Add the following auth providers:\n";
        for (const auth of addedAuth) {
            diff += "[+] " + JSON.stringify(auth) + "\n";
        }
    }
    if (verbose) {
        let versionMessage = "";
        const matches = oldConfig.udfServerVersion === newConfig.udfServerVersion;
        if (oldConfig.udfServerVersion &&
            (!newConfig.udfServerVersion || !matches)) {
            versionMessage += `[-] ${oldConfig.udfServerVersion}\n`;
        }
        if (newConfig.udfServerVersion &&
            (!oldConfig.udfServerVersion || !matches)) {
            versionMessage += `[+] ${newConfig.udfServerVersion}\n`;
        }
        if (versionMessage) {
            diff += "Change the server's function version:\n";
            diff += versionMessage;
        }
    }
    return diff;
}
exports.diffConfig = diffConfig;
//# sourceMappingURL=config.js.map