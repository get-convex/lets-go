"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.poll = exports.BETA_KEY_OPTION = exports.BETA_KEY_DEPRECATION_MESSAGE = exports.getAuthHeader = exports.globalConfigPath = exports.rootDirectory = exports.functionsDir = exports.exists = exports.sorted = exports.isConvexPackage = exports.pkgVersionConsistencyCheck = exports.loadPackageJson = exports.deprecationCheck = exports.printServerErr = exports.flushAndExit = exports.prompt = void 0;
const axios_1 = __importDefault(require("axios"));
const chalk_1 = __importDefault(require("chalk"));
const readline = __importStar(require("readline"));
const promises_1 = __importDefault(require("fs/promises"));
const Sentry = __importStar(require("@sentry/node"));
const path_1 = __importDefault(require("path"));
const os_1 = __importDefault(require("os"));
const zod_1 = require("zod");
const commander_1 = require("commander");
const index_js_1 = require("../index.js");
/** Prompt for keyboard input with the given `query` string and return a promise
 * that resolves to the input. */
function prompt(query) {
    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout,
    });
    return new Promise(resolve => rl.question(query, answer => {
        rl.close();
        resolve(answer);
    }));
}
exports.prompt = prompt;
/**
 * Exits the program after flushing the Sentry client, optionally reporting a passed exception.
 *
 * Callers should `return await flushAndExit(...)` to ensure that control flow is blocked until completion.
 * @param exitCode Exit code for the program (should be non-zero in case of error)
 * @param err Optional exception to be reported to Sentry. Generally this should be reserved for "unexpected" fatal errors rather than clear developer errors.
 * @returns Never returns, i.e. this function is diverging and returns `Promise<never>`.
 */
function flushAndExit(exitCode, err) {
    return __awaiter(this, void 0, void 0, function* () {
        if (err) {
            Sentry.captureException(err);
        }
        yield Sentry.close();
        // eslint-disable-next-line no-restricted-syntax
        return process.exit(exitCode);
    });
}
exports.flushAndExit = flushAndExit;
function printServerErr(err) {
    const res = err.response;
    if (res) {
        console.error(chalk_1.default.gray(`${res.status} ${res.statusText}: ${res.data.code}: ${res.data.message}`));
        deprecationCheck(res);
    }
    else {
        console.error(chalk_1.default.gray(err));
    }
}
exports.printServerErr = printServerErr;
function deprecationCheck(resp) {
    const headers = resp.headers;
    if (headers) {
        const deprecationState = headers["x-convex-deprecation-state"];
        const deprecationMessage = headers["x-convex-deprecation-message"];
        switch (deprecationState) {
            case undefined:
                break;
            case "Deprecated":
                console.log(chalk_1.default.red(deprecationMessage));
                break;
            case "Upgradable":
                console.log(chalk_1.default.yellow(deprecationMessage));
                break;
            case "UpgradeCritical":
                console.log(chalk_1.default.red(deprecationMessage));
                break;
            default:
                console.log(deprecationMessage);
                break;
        }
    }
}
exports.deprecationCheck = deprecationCheck;
class PackageJsonLoadError extends Error {
}
function loadPackageJson() {
    return __awaiter(this, void 0, void 0, function* () {
        let packageJson;
        try {
            packageJson = yield promises_1.default.readFile("package.json", { encoding: "utf-8" });
        }
        catch (err) {
            console.error(chalk_1.default.red(`Unable to read your package.json: ${err}. Make sure you're running this command from the root directory of a Convex app that contains the package.json`));
            return yield flushAndExit(1);
        }
        let obj;
        try {
            obj = JSON.parse(packageJson);
        }
        catch (err) {
            console.error(chalk_1.default.red(`Unable to parse package.json: ${err}`));
            return yield flushAndExit(1, err);
        }
        if (typeof obj !== "object") {
            throw new PackageJsonLoadError("Expected to parse an object from package.json");
        }
        const packages = [];
        if (obj.dependencies) {
            for (const dep in obj.dependencies) {
                packages.push({ name: dep, version: obj.dependencies[dep] });
            }
        }
        if (obj.devDependencies) {
            for (const dep in obj.devDependencies) {
                packages.push({ name: dep, version: obj.devDependencies[dep] });
            }
        }
        return packages;
    });
}
exports.loadPackageJson = loadPackageJson;
// Check that all Convex packages in package.json are the same version, printing error and returning false if not
function pkgVersionConsistencyCheck(origin) {
    return __awaiter(this, void 0, void 0, function* () {
        const convexPackages = (yield loadPackageJson()).filter(exports.isConvexPackage);
        const url = `${origin}/api/${index_js_1.version}/check_version_consistency`;
        const client = axios_1.default.create();
        return client
            .put(url, { packages: convexPackages })
            .then(res => {
            if (res.data.message) {
                console.error(chalk_1.default.red(res.data.message));
            }
        })
            .catch(err => {
            printServerErr(err);
        });
    });
}
exports.pkgVersionConsistencyCheck = pkgVersionConsistencyCheck;
const isConvexPackage = (elt) => elt.name.startsWith("@convex-dev") || elt.name.startsWith("convex");
exports.isConvexPackage = isConvexPackage;
/** Return a new array with elements of the passed in array sorted by a key lambda */
const sorted = (arr, key) => {
    const newArr = [...arr];
    const cmp = (a, b) => {
        if (key(a) < key(b))
            return -1;
        if (key(a) > key(b))
            return 1;
        return 0;
    };
    return newArr.sort(cmp);
};
exports.sorted = sorted;
function exists(path) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            yield promises_1.default.access(path);
            return true;
        }
        catch (_a) {
            return false;
        }
    });
}
exports.exists = exists;
function functionsDir(configPath, instanceConfig) {
    return path_1.default.join(path_1.default.dirname(configPath), instanceConfig.functions);
}
exports.functionsDir = functionsDir;
function rootDirectory() {
    let dirName;
    // Use a different directory for config files generated for tests
    if (process.env.USE_TEST_CONFIG_DIR) {
        dirName = ".convex-test";
    }
    else {
        dirName = ".convex";
    }
    return path_1.default.join(os_1.default.homedir(), dirName);
}
exports.rootDirectory = rootDirectory;
function globalConfigPath() {
    return path_1.default.join(rootDirectory(), "config.json");
}
exports.globalConfigPath = globalConfigPath;
function readGlobalConfig() {
    return __awaiter(this, void 0, void 0, function* () {
        const configPath = globalConfigPath();
        let configFile;
        try {
            configFile = yield promises_1.default.readFile(configPath, { encoding: "utf-8" });
        }
        catch (err) {
            console.error(chalk_1.default.red(`Failed to read global config in ${configPath}. Please run \`npx convex login\` to generate your global config.`));
            return null;
        }
        try {
            const schema = zod_1.z.object({
                accessToken: zod_1.z.string().min(1),
            });
            const config = schema.parse(JSON.parse(configFile));
            return config;
        }
        catch (err) {
            console.error(chalk_1.default.red(`Failed to parse global config in ${configPath} with error ${err}. Please run \`npx convex login\` to regenerate your global config.`));
            return null;
        }
    });
}
function getAuthHeader() {
    return __awaiter(this, void 0, void 0, function* () {
        const globalConfig = yield readGlobalConfig();
        if (globalConfig) {
            return `Bearer ${globalConfig.accessToken}`;
        }
        return null;
    });
}
exports.getAuthHeader = getAuthHeader;
exports.BETA_KEY_DEPRECATION_MESSAGE = "Convex beta keys are deprecated. Please run `npx convex login` to log in.";
exports.BETA_KEY_OPTION = new commander_1.Option("--beta-key [key]", `Convex beta key for the closed beta. ${exports.BETA_KEY_DEPRECATION_MESSAGE}`).hideHelp();
/**
 * Polls an arbitrary function until a condition is met.
 *
 * @param fetch Function performing a fetch, returning resulting data.
 * @param condition This function will terminate polling when it returns `true`.
 * @param waitMs How long to wait in between fetches.
 * @returns The resulting data from `fetch`.
 */
const poll = function (fetch, condition, waitMs = 1000) {
    return __awaiter(this, void 0, void 0, function* () {
        let result = yield fetch();
        while (!condition(result)) {
            yield wait(waitMs);
            result = yield fetch();
        }
        return result;
    });
};
exports.poll = poll;
const wait = function (waitMs) {
    return new Promise(resolve => {
        setTimeout(resolve, waitMs);
    });
};
//# sourceMappingURL=utils.js.map