"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.push = void 0;
const commander_1 = require("commander");
const chalk_1 = __importDefault(require("chalk"));
const config_js_1 = require("./config.js");
const utils_js_1 = require("./utils.js");
const typecheck_js_1 = require("./typecheck.js");
const codegen_js_1 = require("./codegen.js");
const indexes_js_1 = require("./indexes.js");
/** Pull the local config and overwrite the remote one. */
exports.push = new commander_1.Command("push")
    .description("Push local Convex functions and configuration to a deployment")
    .option("-v, --verbose", "Show full listing of changes")
    .option("--dry-run", "Print out the generated configuration without sending it to the server")
    .addOption(new commander_1.Option("--typecheck <mode>", `Whether to check TypeScript files with \`tsc --noEmit\` before pushing.`)
    .choices(["enable", "try", "disable"])
    .default("disable"))
    .addOption(new commander_1.Option("--debug").hideHelp())
    .addOption(new commander_1.Option("--codegen <mode>", "Whether to regenerate client code on push.")
    .choices(["enable", "disable"])
    .default("enable"))
    .option("--deployment-type <type>", "Type of deployment to push to (`convex.<type>.json`). Defaults to `convex.json`")
    .action((options) => __awaiter(void 0, void 0, void 0, function* () {
    const adminKey = (yield (0, config_js_1.mustReadEnv)(options.deploymentType)).adminKey;
    const { configPath, instanceConfig } = yield (0, config_js_1.readInstanceConfig)(options.deploymentType);
    const origin = instanceConfig.origin;
    yield (0, utils_js_1.pkgVersionConsistencyCheck)(origin);
    if (options.typecheck !== "disable") {
        console.error(chalk_1.default.gray("Trying experimental TypeScript typecheck, remove --typecheck=enable to disable."));
    }
    let localConfig;
    if (options.codegen === "disable") {
        console.error(chalk_1.default.gray("Skipping codegen. Remove --codegen=disable to enable."));
        // Codegen includes typechecking, so if we're skipping it, run the type
        // check manually on the query and mutation functions
        const funcDir = (0, utils_js_1.functionsDir)(configPath, instanceConfig);
        yield (0, typecheck_js_1.processTypeCheckResult)(options.typecheck, () => (0, typecheck_js_1.typeCheckFunctions)(funcDir));
        localConfig = yield (0, config_js_1.configFromInstanceConfig)(instanceConfig, configPath, options.verbose);
    }
    else {
        localConfig = yield (0, codegen_js_1.doCodegen)({
            instanceConfig,
            configPath,
            adminKey,
            typeCheckMode: options.typecheck,
            dryRun: options.dryRun,
            debug: options.debug,
        });
        console.error(chalk_1.default.green("Codegen finished."));
    }
    if (options.debug) {
        const config = (0, config_js_1.configJSON)(localConfig, adminKey);
        console.log(JSON.stringify(config));
        return;
    }
    yield (0, indexes_js_1.buildIndexes)(localConfig.instanceConfig.origin, adminKey, (0, utils_js_1.functionsDir)(configPath, localConfig.instanceConfig), !!options.dryRun);
    const remoteConfig = yield (0, config_js_1.pullConfig)(origin, adminKey);
    const diff = (0, config_js_1.diffConfig)(remoteConfig, localConfig, configPath, options.verbose);
    if (diff == "") {
        console.log(chalk_1.default.gray(`${options.dryRun
            ? "Command would skip function push"
            : "Function push skipped"}: Deployment config already synced.`));
        return yield (0, utils_js_1.flushAndExit)(0);
    }
    console.log(chalk_1.default.bold(`Remote deployment config ${options.dryRun ? "would" : "will"} be overwritten with the following changes:`));
    console.log(diff);
    if (options.dryRun) {
        return;
    }
    yield (0, config_js_1.pushConfig)(localConfig, adminKey);
    console.log(chalk_1.default.green("Push complete."));
}));
//# sourceMappingURL=push.js.map