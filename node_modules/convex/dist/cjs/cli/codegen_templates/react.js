"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.reactCodegen = exports.importStmt = exports.udfPathKey = void 0;
const common_js_1 = require("./common.js");
const maybeQuote = (s) => (/[":\\/]/.test(s) ? `"${s}"` : s);
const filepathToUdfPath = (filePath) => {
    filePath = filePath.replace("\\", "/");
    const lastDot = filePath.lastIndexOf(".");
    return filePath.slice(0, lastDot === -1 ? undefined : lastDot);
};
const filepathToIdentifier = (filePath) => filepathToUdfPath(filePath).replace("/", "_");
const udfPath = ({ filename, name }) => name === "default"
    ? `${filepathToUdfPath(filename)}`
    : `${filepathToUdfPath(filename)}:${name}`;
// foo or "foo:bar" or "foo/bar:baz" - string when used as object property
const udfPathKey = (imp) => maybeQuote(udfPath(imp));
exports.udfPathKey = udfPathKey;
// foo or foo__bar or foo_bar__baz - must be unique in generated code
const apiName = ({ filename, name }) => name === "default"
    ? filepathToIdentifier(filename)
    : `${filepathToIdentifier(filename)}__${name}`;
// ./foo or ./foo or ./foo/bar
const importPath = ({ filename }) => `../${filepathToUdfPath(filename)}`;
const importStmt = (imp) => imp.name === "default"
    ? `import type ${apiName(imp)} from "${importPath(imp)}";`
    : `import type { ${imp.name} as ${apiName(imp)} } from "${importPath(imp)}";`;
exports.importStmt = importStmt;
function reactCodegen(udfs) {
    return `${(0, common_js_1.header)("Generated React hooks.")}
  ${udfs.map(imp => (0, exports.importStmt)(imp)).join("\n")}

  // This jumpstarts TypeScript completion of the convex/values entry point.
  import type { Id } from "convex/values";
  if ("VSCode" === "sees" + "that this module is imported") {
    const msg = "you get great autocompletion for" + ("Id" as unknown as Id);
    throw new Error(msg);
  }
  import type { OptimisticLocalStore as GenericOptimisticLocalStore } from "convex/browser";
  import type { ClientMutation, ClientQuery } from "convex/server";
  
  /**
   * A type describing your app's public Convex API.
   *
   * This \`ConvexAPI\` type includes information about the arguments and return
   * types of your app's query and mutation functions.
   *
   * This type should be used with type-parameterized classes like
   * \`ConvexReactClient\` to create app-specific types.
   */
  export type ConvexAPI = {
    queries: {
  ${udfs
        .filter(({ isMutation }) => !isMutation)
        .map(imp => `${(0, exports.udfPathKey)(imp)}: ClientQuery<typeof ${apiName(imp)}>;`)
        .join("\n")}
    };
    mutations: {
  ${udfs
        .filter(({ isMutation }) => isMutation)
        .map(imp => `${(0, exports.udfPathKey)(imp)}: ClientMutation<typeof ${apiName(imp)}>;`)
        .join("\n")}
    };
  };
  
  import { makeUseQuery, makeUseMutation, makeUseConvex } from "convex/react";
  
  /**
   * Load a reactive query within a React component.
   *
   * This React hook contains internal state that will cause a rerender whenever
   * the query result changes.
   *
   * This relies on the {@link ConvexProvider} being above in the React component tree.
   *
   * @param name - The name of the query function.
   * @param args - The arguments to the query function.
   * @returns \`undefined\` if loading and the query's return value otherwise.
   */
  export const useQuery = makeUseQuery<ConvexAPI>();
  
  /**
   * Construct a new {@link ReactMutation}.
   *
   * Mutation objects can be called like functions to request execution of the
   * corresponding Convex function, or further configured with
   * [optimistic updates](https://docs.convex.dev/using/optimistic-updates).
   *
   * The value returned by this hook is stable across renders, so it can be used
   * by React dependency arrays and memoization logic relying on object identity
   * without causing rerenders.
   *
   * This relies on the {@link ConvexProvider} being above in the React component tree.
   *
   * @param name - The name of the mutation.
   * @returns The {@link ReactMutation} object with that name.
   */
  export const useMutation = makeUseMutation<ConvexAPI>();
  
  /**
   * Get the {@link ConvexReactClient} within a React component.
   *
   * This relies on the {@link ConvexProvider} being above in the React component tree.
   *
   * @returns The active {@link ConvexReactClient} object, or \`undefined\`.
   */
  export const useConvex = makeUseConvex<ConvexAPI>();

  /**
   * A view of the query results currently in the Convex client for use within
   * optimistic updates.
   */
  export type OptimisticLocalStore = GenericOptimisticLocalStore<ConvexAPI>;
  `;
}
exports.reactCodegen = reactCodegen;
//# sourceMappingURL=react.js.map