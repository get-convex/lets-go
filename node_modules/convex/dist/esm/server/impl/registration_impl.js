import { convexToJson, jsonToConvex } from "@convex-dev/common";
import { setupAuth } from "./authentication_impl.js";
import { setupReader, setupWriter } from "./database_impl.js";
async function invokeMutation(func, argsStr) {
    const args = jsonToConvex(JSON.parse(argsStr));
    const mutationCtx = {
        db: setupWriter(),
        auth: setupAuth(),
    };
    const result = await Promise.resolve(func(mutationCtx, ...args));
    return JSON.stringify(convexToJson(result === undefined ? null : result));
}
/**
 * Define a mutation in this Convex app's public API.
 *
 * This function will be allowed to modify your Convex database and will be accessible from the client.
 *
 * If you're using TypeScript, use the `mutation` function in
 * `convex/_generated/server.ts` which is typed for your data model.
 *
 * @param func - The mutation function. It receives a {@link MutationCtx} as its first argument.
 * @returns The wrapped mutation. Include this as an `export` to name it and make it accessible.
 *
 * @public
 */
export const mutationGeneric = (func) => {
    const m = func;
    // Helpful runtime check that functions are only be registered once
    if (m.isRegistered) {
        throw new Error("Function registered twice " + func);
    }
    m.isRegistered = true;
    m.isMutation = true;
    m.invokeMutation = argsStr => invokeMutation(func, argsStr);
    return m;
};
// Create a `mutation` for a specific `DataModel`.
/**
 * Internal method used by Convex code generation.
 *
 * @public
 */
export const makeMutation = () => (func) => {
    return mutationGeneric(func);
};
async function invokeQuery(func, argsStr) {
    const args = jsonToConvex(JSON.parse(argsStr));
    const queryCtx = {
        db: setupReader(),
        auth: setupAuth(),
    };
    const result = await Promise.resolve(func(queryCtx, ...args));
    return JSON.stringify(convexToJson(result === undefined ? null : result));
}
/**
 * Define a query in this Convex app's public API.
 *
 * This function will be allowed to read your Convex database and will be accessible from the client.
 *
 * If you're using TypeScript, use the `query` function in
 * `convex/_generated/server.ts` which is typed for your data model.
 *
 * @param func - The query function. It receives a {@link QueryCtx} as its first argument.
 * @returns The wrapped query. Include this as an `export` to name it and make it accessible.
 *
 * @public
 */
export const queryGeneric = (func) => {
    const q = func;
    // Helpful runtime check that functions are only be registered once
    if (q.isRegistered) {
        throw new Error("Function registered twice " + func);
    }
    q.isRegistered = true;
    q.isQuery = true;
    q.invokeQuery = argsStr => invokeQuery(func, argsStr);
    return q;
};
// Create a `query` for a specific `DataModel`.
/**
 * Internal method used by Convex code generation.
 *
 * @public
 */
export const makeQuery = () => (func) => {
    return queryGeneric(func);
};
//# sourceMappingURL=registration_impl.js.map