import fs from "fs/promises";
import path from "path";
import chalk from "chalk";
import esbuild from "esbuild";
export async function* walkDir(dirPath) {
    for await (const dirEntry of await fs.opendir(dirPath)) {
        const childPath = path.join(dirPath, dirEntry.name);
        if (dirEntry.isDirectory()) {
            yield* walkDir(childPath);
        }
        else if (dirEntry.isFile()) {
            yield childPath;
        }
    }
}
export class BundleError extends Error {
}
async function doEsbuild(dir, entryPoints, generateSourceMaps) {
    try {
        return await esbuild.build({
            entryPoints,
            bundle: true,
            format: "esm",
            target: "esnext",
            outdir: "out",
            outbase: dir,
            write: false,
            sourcemap: generateSourceMaps,
            splitting: true,
            chunkNames: "_deps/[hash]",
            treeShaking: true,
            minify: false,
        });
    }
    catch (err) {
        throw new BundleError(`esbuild failed: ${err.toString()}`);
    }
}
export async function bundle(dir, entryPoints, generateSourceMaps) {
    const result = await doEsbuild(dir, entryPoints, generateSourceMaps);
    if (result.errors.length) {
        for (const error of result.errors) {
            console.log(chalk.red(`esbuild error: ${error.text}`));
        }
        throw new BundleError("esbuild failed");
    }
    for (const warning of result.warnings) {
        console.log(chalk.yellow(`esbuild warning: ${warning.text}`));
    }
    const sourceMaps = new Map();
    const modules = [];
    for (const outputFile of result.outputFiles) {
        const relPath = path.relative(path.normalize("out"), outputFile.path);
        if (path.extname(relPath) === ".map") {
            sourceMaps.set(relPath, outputFile.text);
            continue;
        }
        modules.push({ path: relPath, source: outputFile.text });
    }
    for (const module of modules) {
        const sourceMapPath = module.path + ".map";
        const sourceMap = sourceMaps.get(sourceMapPath);
        if (sourceMap) {
            module.sourceMap = sourceMap;
        }
    }
    return modules;
}
export async function bundleAll(dir, generateSourceMaps, verbose) {
    const entries = await entryPoints(dir, verbose);
    return bundle(dir, entries, generateSourceMaps);
}
export async function bundleSchema(dir) {
    return bundle(dir, [path.resolve(dir, "schema.ts")], true);
}
export async function entryPoints(dir, verbose) {
    const entryPoints = [];
    for await (const fpath of walkDir(dir)) {
        const relPath = path.relative(dir, fpath);
        const base = path.parse(fpath).base;
        const log = (line) => {
            if (verbose) {
                console.log(line);
            }
        };
        if (relPath.startsWith("_deps/")) {
            throw new Error(`The path "${fpath}" is within the "_deps" directory, which is reserved for dependencies. Please move your code to another directory.`);
        }
        else if (relPath.startsWith("_generated/")) {
            log(chalk.yellow(`Skipping ${fpath}`));
        }
        else if (base.startsWith(".")) {
            log(chalk.yellow(`Skipping dotfile ${fpath}`));
        }
        else if (base === "README.md") {
            log(chalk.yellow(`Skipping ${fpath}`));
        }
        else if (base === "_generated.ts") {
            log(chalk.yellow(`Skipping ${fpath}`));
        }
        else if (base === "schema.ts") {
            log(chalk.yellow(`Skipping ${fpath}`));
        }
        else if (base.includes(".test.")) {
            log(chalk.yellow(`Skipping ${fpath}`));
        }
        else {
            log(chalk.green(`Preparing ${fpath}`));
            entryPoints.push(fpath);
        }
    }
    return entryPoints;
}
//# sourceMappingURL=index.js.map