import { convexToJson, jsonToConvex, version, STATUS_CODE_UDF_FAILED, } from "@convex-dev/common";
import { createError, logToConsole } from "./logging.js";
/** Isomorphic `fetch` for Node.js and browser usage. */
const hasFetch = typeof window !== "undefined" && typeof window.fetch !== "undefined";
const fetch = hasFetch
    ? window.fetch
    : (...args) => import("node-fetch").then(({ default: fetch }) => fetch(...args));
/**
 * A Convex client that runs queries and mutations over HTTP.
 *
 * This is appropriate for server-side code (like Netlify Lambdas) or non-reactive
 * webapps.
 *
 * If you're building a React app, consider using
 * {@link react.ConvexReactClient} instead.
 *
 *
 * @public
 */
export class ConvexHttpClient {
    constructor(address) {
        this.address = `${address}/api/${version}`;
    }
    /**
     * Obtain the {@link ConvexHttpClient}'s URL to its backend.
     *
     * @returns The URL to the Convex backend, including the client's API version.
     */
    backendUrl() {
        return this.address;
    }
    /**
     * Set the authentication token to be used for subsequent queries and mutations.
     *
     * Should be called whenever the token changes (i.e. due to expiration and refresh).
     *
     * @param value - JWT-encoded OpenID Connect identity token.
     */
    setAuth(value) {
        this.auth = value;
    }
    /**
     * Clear the current authentication token if set.
     */
    clearAuth() {
        this.auth = undefined;
    }
    /**
     * Construct a new {@link Query}.
     *
     * @param name - The name of the query function.
     * @returns The {@link Query} object with that name.
     */
    query(name) {
        return async (...args) => {
            // Interpret the arguments as a Convex array, and then serialize
            // it to JSON.
            const argsJSON = JSON.stringify(convexToJson(args));
            const argsComponent = encodeURIComponent(argsJSON);
            const url = `${this.address}/udf?path=${name}&args=${argsComponent}`;
            const headers = this.auth
                ? { Authorization: `Bearer ${this.auth}` }
                : {};
            const response = await fetch(url, {
                credentials: "include",
                headers: headers,
            });
            if (!response.ok && response.status != STATUS_CODE_UDF_FAILED) {
                throw new Error(await response.text());
            }
            const respJSON = await response.json();
            const value = jsonToConvex(respJSON.value);
            for (const line of respJSON.logs) {
                logToConsole("info", "query", name, line);
            }
            if (!respJSON.success) {
                throw createError("query", name, value);
            }
            return value;
        };
    }
    /**
     * Construct a new {@link Mutation}.
     *
     * @param name - The name of the mutation function.
     * @returns The {@link Mutation} object with that name.
     */
    mutation(name) {
        return async (...args) => {
            // Interpret the arguments as a Convex array and then serialize to JSON.
            const body = JSON.stringify({
                path: name,
                args: convexToJson(args),
                tokens: [],
            });
            const headers = {
                "Content-Type": "application/json",
            };
            if (this.auth) {
                headers["Authorization"] = `Bearer ${this.auth}`;
            }
            const response = await fetch(`${this.address}/udf`, {
                body,
                method: "POST",
                headers: headers,
                credentials: "include",
            });
            if (!response.ok && response.status != STATUS_CODE_UDF_FAILED) {
                throw new Error(await response.text());
            }
            const respJSON = await response.json();
            const value = jsonToConvex(respJSON.value);
            for (const line of respJSON.logs) {
                logToConsole("info", "mutation", name, line);
            }
            if (!respJSON.success) {
                throw createError("mutation", name, value);
            }
            return value;
        };
    }
}
//# sourceMappingURL=http_client.js.map