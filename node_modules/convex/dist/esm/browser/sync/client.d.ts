import { Value } from "@convex-dev/common";
import { OptimisticUpdate } from "./optimistic_query_set.js";
import { QueryToken } from "./udf_path_utils.js";
import { GenericAPI } from "../api.js";
/**
 * Options for {@link InternalConvexClient}.
 *
 * @public
 */
export declare type ClientOptions = {
    /**
     * Whether to prompt the user that have unsaved changes pending
     * when navigating away or closing a web page with pending Convex mutations.
     * This is only possible when the `window` object exists, i.e. in a browser.
     * The default value is `true`.
     */
    unsavedChangesWarning?: boolean;
    /**
     * Specifies an alternate
     * [WebSocket](https://developer.mozilla.org/en-US/docs/Web/API/WebSocket)
     * constructor to use for client communication with the Convex cloud.
     * The default behavior is to use `WebSocket` from the global environment.
     */
    webSocketConstructor?: typeof WebSocket;
};
/**
 * Low-level client for directly integrating state management libraries
 * with Convex.
 *
 * Most developers should use higher level clients, like
 * the {@link ConvexHttpClient} or the React hook based {@link react.ConvexReactClient}.
 *
 * @public
 */
export declare class InternalConvexClient {
    private readonly state;
    private readonly mutationManager;
    private readonly webSocketManager;
    private remoteQuerySet;
    private readonly optimisticQueryResults;
    private readonly onTransition;
    private nextMutationId;
    private readonly sessionId;
    private connectionCount;
    /**
     * @param address - The url of your Convex deployment, typically from the
     * `origin` property of a convex.json config file.
     * E.g. `https://small-mouse-123.convex.cloud`.
     * @param onTransition - A callback receiving an array of serialized queries,
     * called each time updated query results are received from the Convex cloud.
     * @param options - See {@link ClientOptions} for a full description.
     */
    constructor(address: string, onTransition: (updatedQueries: QueryToken[]) => void, options?: ClientOptions);
    /**
     * Compute the current query results based on the remoteQuerySet and the
     * current optimistic updates and call `onTransition` for all the changed
     * queries.
     *
     * @param completedMutations - A set of mutation IDs whose optimistic updates
     * are no longer needed.
     */
    private notifyOnQueryResultChanges;
    setAuth(value: string): void;
    /** @internal */
    setAdminAuth(value: string): void;
    clearAuth(): void;
    subscribe(udfPath: string, args: any[]): {
        queryToken: QueryToken;
        unsubscribe: () => void;
    };
    /**
     * A query result based only on the current, local state.
     *
     * The only way this will return a value is if we're already subscribed to the
     * query or its value has been set optimistically.
     */
    localQueryResult(udfPath: string, args: any[]): Value | undefined;
    mutate<Args extends any[]>(udfPath: string, args: Args, optimisticUpdate?: OptimisticUpdate<GenericAPI, Args> | null): Promise<any>;
    close(): Promise<void>;
}
//# sourceMappingURL=client.d.ts.map