import { createError } from "../logging.js";
import { serializePathAndArgs } from "./udf_path_utils.js";
/**
 * The implementation of `OptimisticLocalStore`.
 *
 * This class provides the interface for optimistic updates to modify query results.
 */
class OptimisticLocalStoreImpl {
    constructor(queryResults) {
        this.queryResults = queryResults;
        this.modifiedQueries = [];
    }
    getQuery(name, args) {
        const query = this.queryResults.get(serializePathAndArgs(name, args));
        if (query === undefined) {
            return undefined;
        }
        const result = query.result;
        if (result === undefined) {
            return undefined;
        }
        else if (result.success) {
            return result.value;
        }
        else {
            // If the query is an error state, just return `undefined` as though
            // it's loading. Optimistic updates should already handle `undefined` well
            // and there isn't a need to break the whole update because it tried
            // to load a single query that errored.
            return undefined;
        }
    }
    setQuery(name, args, value) {
        const queryToken = serializePathAndArgs(name, args);
        let result;
        if (value === undefined) {
            result = undefined;
        }
        else {
            result = {
                success: true,
                value,
            };
        }
        const query = {
            udfPath: name,
            args,
            result,
        };
        this.queryResults.set(queryToken, query);
        this.modifiedQueries.push(queryToken);
    }
}
/**
 * A view of all of our query results with optimistic updates applied on top.
 */
export class OptimisticQueryResults {
    constructor() {
        this.queryResults = new Map();
        this.optimisticUpdates = [];
    }
    ingestQueryResultsFromServer(serverQueryResults, optimisticUpdatesToDrop) {
        this.optimisticUpdates = this.optimisticUpdates.filter(updateAndId => {
            return !optimisticUpdatesToDrop.has(updateAndId.mutationId);
        });
        const oldQueryResults = this.queryResults;
        this.queryResults = new Map(serverQueryResults);
        const localStore = new OptimisticLocalStoreImpl(this.queryResults);
        for (const updateAndId of this.optimisticUpdates) {
            updateAndId.update(localStore);
        }
        // To find the changed queries, just do a shallow comparison
        // TODO(CX-733): Change this so we avoid unnecessary rerenders
        const changedQueries = [];
        for (const [queryToken, query] of this.queryResults) {
            const oldQuery = oldQueryResults.get(queryToken);
            if (oldQuery === undefined || oldQuery.result !== query.result) {
                changedQueries.push(queryToken);
            }
        }
        return changedQueries;
    }
    applyOptimisticUpdate(update, mutationId) {
        // Apply the update to our store
        this.optimisticUpdates.push({
            update,
            mutationId,
        });
        const localStore = new OptimisticLocalStoreImpl(this.queryResults);
        update(localStore);
        // Notify about any query results that changed
        // TODO(CX-733): Change this so we avoid unnecessary rerenders
        return localStore.modifiedQueries;
    }
    queryResult(queryToken) {
        const query = this.queryResults.get(queryToken);
        if (query === undefined) {
            return undefined;
        }
        const result = query.result;
        if (result === undefined) {
            return undefined;
        }
        else if (result.success) {
            return result.value;
        }
        else {
            throw createError("query", query.udfPath, result.errorMessage);
        }
    }
}
//# sourceMappingURL=optimistic_query_set.js.map