import { version } from "../../index.js";
import { LocalSyncState } from "./local_state.js";
import { MutationManager } from "./mutation_manager.js";
import { OptimisticQueryResults, } from "./optimistic_query_set.js";
import { RemoteQuerySet } from "./remote_query_set.js";
import { serializePathAndArgs } from "./udf_path_utils.js";
import { WebSocketManager } from "./web_socket_manager.js";
import { v4 as uuidv4 } from "uuid";
import { logFatalError } from "../logging.js";
const DEFAULT_OPTIONS = {
    unsavedChangesWarning: true,
};
/**
 * Low-level client for directly integrating state management libraries
 * with Convex.
 *
 * Most developers should use higher level clients, like
 * the {@link ConvexHttpClient} or the React hook based {@link react.ConvexReactClient}.
 *
 * @public
 */
export class InternalConvexClient {
    /**
     * @param address - The url of your Convex deployment, typically from the
     * `origin` property of a convex.json config file.
     * E.g. `https://small-mouse-123.convex.cloud`.
     * @param onTransition - A callback receiving an array of serialized queries,
     * called each time updated query results are received from the Convex cloud.
     * @param options - See {@link ClientOptions} for a full description.
     */
    constructor(address, onTransition, options) {
        options = { ...DEFAULT_OPTIONS, ...options };
        let webSocketConstructor = options.webSocketConstructor;
        if (!webSocketConstructor && typeof WebSocket === "undefined") {
            throw new Error("No WebSocket global variable defined! To use Convex in an environment without WebSocket try the HTTP client: https://docs.convex.dev/api/classes/browser.ConvexHttpClient");
        }
        webSocketConstructor = webSocketConstructor || WebSocket;
        // Substitute http(s) with ws(s)
        const i = address.search("://");
        if (i == -1) {
            throw new Error("Provided address was not an absolute URL.");
        }
        const origin = address.substring(i + 3); // move past the double slash
        const protocol = address.substring(0, i);
        let wsProtocol;
        if (protocol === "http") {
            wsProtocol = "ws";
        }
        else if (protocol === "https") {
            wsProtocol = "wss";
        }
        else {
            throw new Error(`Unknown parent protocol ${protocol}`);
        }
        const wsUri = `${wsProtocol}://${origin}/api/${version}/sync`;
        this.state = new LocalSyncState();
        this.remoteQuerySet = new RemoteQuerySet(queryId => this.state.queryPath(queryId));
        this.mutationManager = new MutationManager();
        this.optimisticQueryResults = new OptimisticQueryResults();
        this.onTransition = onTransition;
        this.nextMutationId = 0;
        this.sessionId = uuidv4();
        this.connectionCount = 0;
        const { unsavedChangesWarning } = options;
        if (typeof window === "undefined" && unsavedChangesWarning) {
            throw new Error("unsavedChangesWarning enabled, but no window object found! Navigating away from the page could cause in-flight mutations to be dropped. Pass {unsavedChangesWarning: false} in Convex client options to disable this feature.");
        }
        // Listen for tab close events and notify the user on unsaved changes.
        unsavedChangesWarning &&
            window.addEventListener("beforeunload", e => {
                if (this.mutationManager.hasUncommittedMutations()) {
                    // There are 3 different ways to trigger this pop up so just try all of
                    // them.
                    e.preventDefault();
                    // This confirmation message doesn't actually appear in most modern
                    // browsers but we tried.
                    const confirmationMessage = "Are you sure you want to leave? Your changes may not be saved.";
                    (e || window.event).returnValue = confirmationMessage;
                    return confirmationMessage;
                }
            });
        this.webSocketManager = new WebSocketManager(wsUri, () => {
            // We have a new WebSocket!
            this.webSocketManager.sendMessage({
                type: "Connect",
                sessionId: this.sessionId,
                connectionCount: this.connectionCount,
            });
            this.connectionCount += 1;
            // Throw out our remote query, reissue queries
            // and outstanding mutations, and reauthenticate.
            this.remoteQuerySet = new RemoteQuerySet(queryId => this.state.queryPath(queryId));
            const [querySetModification, authModification] = this.state.restart();
            if (authModification) {
                this.webSocketManager.sendMessage(authModification);
            }
            this.webSocketManager.sendMessage(querySetModification);
            for (const message of this.mutationManager.restart()) {
                this.webSocketManager.sendMessage(message);
            }
        }, (serverMessage) => {
            if (serverMessage.type == "Transition") {
                this.remoteQuerySet.transition(serverMessage);
                const completedMutations = this.mutationManager.removeCompletedMutations(this.remoteQuerySet.timestamp());
                this.notifyOnQueryResultChanges(completedMutations);
            }
            else if (serverMessage.type == "MutationResponse") {
                const completedMutationId = this.mutationManager.onResponse(serverMessage);
                if (completedMutationId) {
                    this.notifyOnQueryResultChanges(new Set([completedMutationId]));
                }
            }
            else if (serverMessage.type == "FatalError") {
                const error = logFatalError(serverMessage.error);
                this.webSocketManager.stop();
                throw error;
            }
        }, webSocketConstructor);
    }
    /**
     * Compute the current query results based on the remoteQuerySet and the
     * current optimistic updates and call `onTransition` for all the changed
     * queries.
     *
     * @param completedMutations - A set of mutation IDs whose optimistic updates
     * are no longer needed.
     */
    notifyOnQueryResultChanges(completedMutations) {
        const remoteQueryResults = this.remoteQuerySet.remoteQueryResults();
        const queryTokenToValue = new Map();
        for (const [queryId, result] of remoteQueryResults) {
            const queryToken = this.state.queryToken(queryId);
            // It's possible that we've already unsubscribed to this query but
            // the server hasn't learned about that yet. If so, ignore this one.
            if (queryToken !== null) {
                const query = {
                    result,
                    udfPath: this.state.queryPath(queryId),
                    args: this.state.queryArgs(queryId),
                };
                queryTokenToValue.set(queryToken, query);
            }
        }
        this.onTransition(this.optimisticQueryResults.ingestQueryResultsFromServer(queryTokenToValue, completedMutations));
    }
    setAuth(value) {
        const message = this.state.setAuth(value);
        this.webSocketManager.sendMessage(message);
    }
    /** @internal */
    setAdminAuth(value) {
        const message = this.state.setAdminAuth(value);
        this.webSocketManager.sendMessage(message);
    }
    clearAuth() {
        const message = this.state.clearAuth();
        this.webSocketManager.sendMessage(message);
    }
    subscribe(udfPath, args) {
        const { modification, queryToken, unsubscribe } = this.state.subscribe(udfPath, args);
        if (modification !== null) {
            this.webSocketManager.sendMessage(modification);
        }
        // TODO: Use FinalizationRegistry?
        return {
            queryToken,
            unsubscribe: () => {
                const modification = unsubscribe();
                if (modification) {
                    this.webSocketManager.sendMessage(modification);
                }
            },
        };
    }
    /**
     * A query result based only on the current, local state.
     *
     * The only way this will return a value is if we're already subscribed to the
     * query or its value has been set optimistically.
     */
    localQueryResult(udfPath, args) {
        const queryToken = serializePathAndArgs(udfPath, args);
        return this.optimisticQueryResults.queryResult(queryToken);
    }
    async mutate(udfPath, args, optimisticUpdate = null) {
        const mutationId = this.nextMutationId;
        this.nextMutationId++;
        if (optimisticUpdate !== null) {
            const wrappedUpdate = (localQueryStore) => {
                optimisticUpdate(localQueryStore, ...args);
            };
            const changedQueries = this.optimisticQueryResults.applyOptimisticUpdate(wrappedUpdate, mutationId);
            this.onTransition(changedQueries);
        }
        const { message, result } = this.mutationManager.request(udfPath, args, mutationId);
        this.webSocketManager.sendMessage(message);
        return result;
    }
    async close() {
        return this.webSocketManager.stop();
    }
}
//# sourceMappingURL=client.js.map