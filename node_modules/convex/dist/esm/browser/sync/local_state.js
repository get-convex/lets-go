import { convexToJson } from "@convex-dev/common";
import { canonicalizeUdfPath, serializePathAndArgs, } from "./udf_path_utils.js";
export class LocalSyncState {
    constructor() {
        this.nextQueryId = 0;
        this.querySetVersion = 0;
        this.identityVersion = 0;
        this.querySet = new Map();
        this.queryIdToToken = new Map();
    }
    subscribe(udfPath, args) {
        const canonicalizedUdfPath = canonicalizeUdfPath(udfPath);
        const queryToken = serializePathAndArgs(canonicalizedUdfPath, args);
        const existingEntry = this.querySet.get(queryToken);
        if (existingEntry !== undefined) {
            existingEntry.numSubscribers += 1;
            return {
                queryToken,
                modification: null,
                unsubscribe: () => this.removeSubscriber(queryToken),
            };
        }
        else {
            const queryId = this.nextQueryId++;
            const query = {
                id: queryId,
                canonicalizedUdfPath,
                args,
                numSubscribers: 1,
            };
            this.querySet.set(queryToken, query);
            this.queryIdToToken.set(queryId, queryToken);
            const baseVersion = this.querySetVersion;
            const newVersion = ++this.querySetVersion;
            const add = {
                type: "Add",
                queryId,
                udfPath: canonicalizedUdfPath,
                args: args.map(convexToJson),
            };
            const modification = {
                type: "ModifyQuerySet",
                baseVersion,
                newVersion,
                modifications: [add],
            };
            return {
                queryToken,
                modification,
                unsubscribe: () => this.removeSubscriber(queryToken),
            };
        }
    }
    queryId(udfPath, args) {
        const canonicalizedUdfPath = canonicalizeUdfPath(udfPath);
        const queryToken = serializePathAndArgs(canonicalizedUdfPath, args);
        const existingEntry = this.querySet.get(queryToken);
        if (existingEntry !== undefined) {
            return existingEntry.id;
        }
        return null;
    }
    setAuth(value) {
        this.auth = {
            tokenType: "User",
            value: value,
        };
        const baseVersion = this.identityVersion++;
        return {
            type: "Authenticate",
            baseVersion: baseVersion,
            ...this.auth,
        };
    }
    setAdminAuth(value) {
        this.auth = {
            tokenType: "Admin",
            value: value,
        };
        const baseVersion = this.identityVersion++;
        return {
            type: "Authenticate",
            baseVersion: baseVersion,
            ...this.auth,
        };
    }
    clearAuth() {
        this.auth = undefined;
        const baseVersion = this.identityVersion++;
        return {
            type: "Authenticate",
            tokenType: "None",
            baseVersion: baseVersion,
        };
    }
    queryPath(queryId) {
        const pathAndArgs = this.queryIdToToken.get(queryId);
        if (pathAndArgs) {
            return this.querySet.get(pathAndArgs).canonicalizedUdfPath;
        }
        return null;
    }
    queryArgs(queryId) {
        const pathAndArgs = this.queryIdToToken.get(queryId);
        if (pathAndArgs) {
            return this.querySet.get(pathAndArgs).args;
        }
        return null;
    }
    queryToken(queryId) {
        return this.queryIdToToken.get(queryId) ?? null;
    }
    restart() {
        const modifications = [];
        for (const localQuery of this.querySet.values()) {
            const add = {
                type: "Add",
                queryId: localQuery.id,
                udfPath: localQuery.canonicalizedUdfPath,
                args: localQuery.args.map(convexToJson),
            };
            modifications.push(add);
        }
        this.querySetVersion = 1;
        const querySet = {
            type: "ModifyQuerySet",
            baseVersion: 0,
            newVersion: 1,
            modifications,
        };
        // If there's no auth, no need to send an update as the server will also start with an unknown identity.
        if (!this.auth) {
            this.identityVersion = 0;
            return [querySet, undefined];
        }
        const authenticate = {
            type: "Authenticate",
            baseVersion: 0,
            ...this.auth,
        };
        this.identityVersion = 1;
        return [querySet, authenticate];
    }
    removeSubscriber(queryToken) {
        const localQuery = this.querySet.get(queryToken);
        if (localQuery.numSubscribers > 1) {
            localQuery.numSubscribers -= 1;
            return null;
        }
        else {
            this.querySet.delete(queryToken);
            this.queryIdToToken.delete(localQuery.id);
            const baseVersion = this.querySetVersion;
            const newVersion = ++this.querySetVersion;
            const remove = {
                type: "Remove",
                queryId: localQuery.id,
            };
            return {
                type: "ModifyQuerySet",
                baseVersion,
                newVersion,
                modifications: [remove],
            };
        }
    }
}
//# sourceMappingURL=local_state.js.map