import axios from "axios";
import chalk from "chalk";
import fs from "fs";
import ora from "ora";
import path from "path";
import { bundleSchema } from "../bundler/index.js";
import { version } from "../index.js";
import { deprecationCheck, flushAndExit, poll, printServerErr, } from "./utils.js";
function stringifyIndex(index) {
    return `${index.table}.${index.name} ${JSON.stringify(index.fields)}`;
}
function diffIndexes(indexes) {
    let indexDiff = "";
    if (indexes.dropped.length > 0) {
        indexDiff += "Delete the following indexes:\n";
        for (const index of indexes.dropped) {
            indexDiff += `[-] ${stringifyIndex(index)}\n`;
        }
    }
    if (indexes.added.length > 0) {
        indexDiff += "Add the following indexes:\n";
        for (const index of indexes.added) {
            indexDiff += `[+] ${stringifyIndex(index)}\n`;
        }
    }
    return indexDiff;
}
export async function buildIndexes(origin, adminKey, schemaDir, dryRun) {
    if (!fs.existsSync(path.resolve(schemaDir, "schema.ts"))) {
        // Don't do anything.
        return;
    }
    const bundles = await bundleSchema(schemaDir);
    const spinner = ora({
        text: "Checking for changed table indexes...",
        stream: process.stdout,
    });
    if (!dryRun) {
        spinner.start();
    }
    try {
        const res = await axios.post(`${origin}/api/${version}/build_indexes`, {
            bundle: bundles[0],
            adminKey,
            dryRun,
        });
        deprecationCheck(res);
        const indexDiff = diffIndexes(res.data);
        if (indexDiff !== "") {
            console.log(chalk.bold(`\nIndexes ${dryRun ? "would" : "will"} be overwritten with the following changes:`));
            console.log(indexDiff);
        }
        if (dryRun) {
            return;
        }
        spinner.text = "Waiting for all table indexes to be backfilled...";
        await waitForIndexesToBuild(origin, adminKey);
        res.data.added.length > 0
            ? spinner.succeed(chalk.green("Successfully backfilled table indexes."))
            : res.data.dropped.length > 0
                ? spinner.succeed(chalk.green("Successfully dropped deleted table indexes."))
                : spinner.stop();
    }
    catch (err) {
        spinner.fail(chalk.red("Error: Unable to build indexes on", origin));
        printServerErr(err);
        return await flushAndExit(1, err);
    }
}
async function waitForIndexesToBuild(origin, adminKey) {
    const fetch = () => axios.get(`${origin}/api/${version}/get_indexes`, {
        headers: { Authorization: `Convex ${adminKey}` },
    });
    const validate = (result) => result.data.indexes.every(index => index.backfill.state === "done");
    await poll(fetch, validate);
}
//# sourceMappingURL=indexes.js.map