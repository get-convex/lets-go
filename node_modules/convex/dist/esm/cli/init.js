import axios from "axios";
import { Command } from "commander";
import chalk from "chalk";
import fs from "fs";
import { provisionHost, pullConfig, writeAdminKey, writeInstanceConfig, configName, readEnv, envFilename, configFilepath, readInstanceConfig, } from "./config.js";
import { version } from "../index.js";
import { getAuthHeader, deprecationCheck, exists, flushAndExit, BETA_KEY_OPTION, BETA_KEY_DEPRECATION_MESSAGE, printServerErr, } from "./utils.js";
import inquirer from "inquirer";
import ora from "ora";
import { dirname } from "path";
import { doCodegen } from "./codegen.js";
/** Initialize a new Convex deployment. */
export const init = new Command("init")
    .description("Initialize a new Convex deployment in the current directory")
    .addOption(BETA_KEY_OPTION)
    .option("--deployment-type <type>", "Type of deployment to create (`convex.<type>.json`). Defaults to `convex.json`")
    .action(async (options) => {
    if (options.betaKey) {
        console.error(chalk.yellow(BETA_KEY_DEPRECATION_MESSAGE));
    }
    const authHeader = await getAuthHeader();
    const name = configName(options.deploymentType);
    const configPath = await configFilepath(name);
    if (await exists(configPath)) {
        const deploymentTypeFlag = options.deploymentType != undefined
            ? ` --deployment-type=${options.deploymentType}`
            : "";
        console.error(chalk.red(`Deployment "${configPath}" already exists.`));
        console.error(`Use \`convex push${deploymentTypeFlag}\` to apply changes to the existing deployment.`);
        console.error(`Use \`convex deactivate${deploymentTypeFlag}\` to deactivate the existing deployment and reclaim a deployment towards your deployment quota.`);
        console.error();
        console.error("Use `convex init --deployment-type={type}` to create an additional deployment.");
        console.error("- Eg: `convex init --deployment-type=dev`");
        return await flushAndExit(1);
    }
    const existingConfig = fs
        .readdirSync(dirname(configPath))
        .find(e => e.match("^convex.*.json$"));
    let existingInstanceName;
    if (existingConfig != undefined) {
        const matches = existingConfig.match("^convex.(.*).json$");
        const existingDeployment = matches && matches[1];
        const { instanceConfig } = await readInstanceConfig(existingDeployment);
        existingInstanceName = instanceConfig.instanceName;
    }
    const envFn = envFilename(options.deploymentType);
    const env = await readEnv(options.deploymentType);
    if (env != null) {
        console.error(chalk.red(`File "${envFn}" already exists.`));
        console.error("Remove this file to create a new project.");
        return await flushAndExit(1);
    }
    // Do opt in to TOS and Privacy Policy stuff first.
    const shouldContinue = await optins(options.betaKey, authHeader);
    if (!shouldContinue) {
        return await flushAndExit(1);
    }
    const spinner = ora({
        text: "Creating new Convex deployment...\n",
        stream: process.stdout,
    }).start();
    const { instanceOrigin, adminKey, redemptionsRemaining } = await provision(authHeader, options.betaKey, existingInstanceName, options.deploymentType);
    const { instanceConfig, modules } = await pullConfig(instanceOrigin, adminKey);
    spinner.succeed(`Successfully deployed ${instanceOrigin}`);
    if (modules.length > 0) {
        console.error(chalk.red("Error: Unexpected modules in new project"));
        return await flushAndExit(1);
    }
    await writeAdminKey(options.deploymentType, adminKey);
    await writeInstanceConfig(options.deploymentType, instanceConfig);
    console.log(chalk.green(`Done! Your account now has ${redemptionsRemaining} deployments remaining.`));
    {
        const { instanceConfig, configPath } = await readInstanceConfig(options.deploymentType);
        await doCodegen({
            instanceConfig,
            configPath,
            adminKey,
            // Don't typecheck because there isn't any code to check yet.
            typeCheckMode: "disable",
            // Schema files will always be missing initially so skip the warning this
            // time.
            warnOnMissingSchemaFile: false,
        });
    }
    console.log(chalk.bold.red("\nConvex is an early beta product and provides no reliability guarantees!"));
    console.log("Please don't use the current version of Convex for any mission-critical applications.");
    console.log(chalk.bold("\nWe would love feedback at either:"));
    console.log("- https://convex.dev/slack");
    console.log("- support@convex.dev\n");
    console.log("Configuration settings have been written to", chalk.bold(configPath));
    console.log("The admin key was written to", chalk.bold(envFn));
    console.log("See documentation at", chalk.bold("https://docs.convex.dev"), "for next steps.");
});
/** Provision a new empty deployment and return the origin. */
async function provision(authHeader, betaKey, existingInstanceName, deployment) {
    const headers = authHeader
        ? { Authorization: authHeader }
        : {};
    const provisioningArgs = {
        betaKey,
        existingInstanceName,
        deployment,
        backendVersionOverride: process.env.CONVEX_BACKEND_VERSION_OVERRIDE,
    };
    const provisionUrl = `${provisionHost}/api/${version}/provision`;
    const client = axios.create();
    try {
        const res = await client.post(provisionUrl, provisioningArgs, {
            headers,
        });
        deprecationCheck(res);
        const instanceOrigin = res.data.url;
        const instanceName = res.data.instanceName;
        const adminKey = res.data.adminKey;
        const redemptionsRemaining = res.data.redemptionsRemaining;
        if (adminKey === undefined ||
            instanceOrigin === undefined ||
            redemptionsRemaining === undefined) {
            const msg = "Unknown error during provisioning: " + JSON.stringify(res.data);
            console.error(chalk.red(msg));
            return await flushAndExit(1, new Error(msg));
        }
        return { instanceName, instanceOrigin, adminKey, redemptionsRemaining };
    }
    catch (err) {
        console.error(chalk.red("Error: Unable to provision deployment"));
        printServerErr(err);
        return await flushAndExit(1, err);
    }
}
// Returns whether we can proceed or not.
export async function optins(betaKey, authHeader) {
    const headers = authHeader
        ? { Authorization: authHeader }
        : {};
    const checkOptInsUrl = `${provisionHost}/api/${version}/check_opt_ins`;
    const client = axios.create();
    let res;
    try {
        const args = { betaKey };
        res = (await client.post(checkOptInsUrl, args, { headers })).data;
    }
    catch (err) {
        printServerErr(err);
        return Promise.resolve(false);
    }
    if (res.optInsToAccept.length == 0) {
        return Promise.resolve(true);
    }
    for (const optInToAccept of res.optInsToAccept) {
        const confirmed = (await inquirer.prompt([
            {
                type: "confirm",
                name: "confirmed",
                message: optInToAccept.message,
            },
        ])).confirmed;
        if (!confirmed) {
            console.log("Please accept the Terms of Service to use Convex.");
            return Promise.resolve(false);
        }
    }
    const optInsAccepted = res.optInsToAccept.map(o => o.optIn);
    const args = { betaKey, optInsAccepted };
    const acceptOptInsUrl = `${provisionHost}/api/${version}/accept_opt_ins`;
    try {
        await client.post(acceptOptInsUrl, args, { headers });
    }
    catch (err) {
        printServerErr(err);
        return Promise.resolve(false);
    }
    return Promise.resolve(true);
}
//# sourceMappingURL=init.js.map