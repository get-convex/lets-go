import { Command, Option } from "commander";
import { Issuer, errors, custom } from "openid-client";
import { globalConfigPath, rootDirectory, flushAndExit, printServerErr, } from "./utils.js";
import open from "open";
import fs from "fs";
import chalk from "chalk";
import { provisionHost } from "./config.js";
import { version } from "../index.js";
import axios from "axios";
// Per https://github.com/panva/node-openid-client/tree/main/docs#customizing
custom.setHttpOptionsDefaults({
    timeout: 10000,
});
async function writeGlobalConfig(config) {
    const dirName = rootDirectory();
    if (!fs.existsSync(dirName)) {
        fs.mkdirSync(dirName);
    }
    const path = globalConfigPath();
    try {
        fs.writeFileSync(path, JSON.stringify(config));
    }
    catch (err) {
        console.log(chalk.red(`Failed to write auth config to ${path} with error: ${err}`));
        return await flushAndExit(1, err);
    }
    console.log(chalk.green(`Successfully wrote your auth credentials to ${path}!`));
}
async function performDeviceAuthorization(auth0Client) {
    // Device authorization flow follows this guide: https://github.com/auth0/auth0-device-flow-cli-sample/blob/9f0f3b76a6cd56ea8d99e76769187ea5102d519d/cli.js
    // Device Authorization Request - https://tools.ietf.org/html/rfc8628#section-3.1
    // Get authentication URL
    const handle = await auth0Client.deviceAuthorization({
        scope: "openid email",
        audience: "https://console.convex.dev/api/",
    });
    // Device Authorization Response - https://tools.ietf.org/html/rfc8628#section-3.2
    // Open authentication URL
    const { verification_uri_complete, user_code, expires_in } = handle;
    console.log(`Opening ${verification_uri_complete} in your browser to log in...`);
    open(verification_uri_complete);
    console.log(`You should see the following code: ${user_code}. It expires in ${expires_in % 60 === 0
        ? `${expires_in / 60} minutes`
        : `${expires_in} seconds`}`);
    // Device Access Token Request - https://tools.ietf.org/html/rfc8628#section-3.4
    // Device Access Token Response - https://tools.ietf.org/html/rfc8628#section-3.5
    try {
        const tokens = await handle.poll();
        if (typeof tokens.access_token == "string") {
            return tokens.access_token;
        }
        else {
            throw Error("Access token is missing");
        }
    }
    catch (err) {
        switch (err.error) {
            case "access_denied": // end-user declined the device confirmation prompt, consent or rules failed
                console.error("Access denied.");
                return await flushAndExit(1, err);
            case "expired_token": // end-user did not complete the interaction in time
                console.error("Device flow expired.");
                return await flushAndExit(1, err);
            default:
                if (err instanceof errors.OPError) {
                    console.error(`Error = ${err.error}; error_description = ${err.error_description}`);
                }
                else {
                    console.error(`Login failed with error: ${err}`);
                }
                return await flushAndExit(1, err);
        }
    }
}
async function performPasswordAuthentication(issuer, clientId, username, password) {
    // Unfortunately, `openid-client` doesn't support the resource owner password credentials flow so we need to manually send the requests.
    const options = {
        method: "POST",
        url: new URL("/oauth/token", issuer).href,
        headers: { "content-type": "application/x-www-form-urlencoded" },
        data: new URLSearchParams({
            grant_type: "password",
            username: username,
            password: password,
            scope: "openid email",
            client_id: clientId,
            audience: "https://console.convex.dev/api/",
            // Note that there is no client secret provided, as Auth0 refuses to require it for untrusted apps.
        }),
    };
    try {
        const response = await axios.request(options);
        if (typeof response.data.access_token == "string") {
            return response.data.access_token;
        }
        else {
            throw Error("Access token is missing");
        }
    }
    catch (err) {
        console.log(`Password flow failed: ${err}`);
        return await flushAndExit(1, err);
    }
}
export const login = new Command("login")
    .description("Login to Convex")
    // These options are hidden from the help/usage message, but allow overriding settings for testing.
    .addOption(new Option("--override-auth-url <url>").hideHelp())
    .addOption(new Option("--override-auth-client <id>").hideHelp())
    .addOption(new Option("--override-auth-username <username>").hideHelp())
    .addOption(new Option("--override-auth-password <password>").hideHelp())
    .action(async (options, cmd) => {
    if (!!options.overrideAuthUsername !== !!options.overrideAuthPassword) {
        cmd.error("If overriding credentials, both username and password must be provided");
    }
    const issuer = options.overrideAuthUrl ?? "https://auth.convex.dev";
    const auth0 = await Issuer.discover(issuer);
    const clientId = options.overrideAuthClient ?? "HFtA247jp9iNs08NTLIB7JsNPMmRIyfi";
    const auth0Client = new auth0.Client({
        client_id: clientId,
        token_endpoint_auth_method: "none",
        id_token_signed_response_alg: "RS256",
    });
    let accessToken;
    if (options.overrideAuthUsername) {
        accessToken = await performPasswordAuthentication(issuer, clientId, options.overrideAuthUsername, options.overrideAuthPassword);
    }
    else {
        accessToken = await performDeviceAuthorization(auth0Client);
    }
    // Get access token from big-brain
    const client = axios.create();
    const authorizeArgs = {
        authnToken: accessToken,
    };
    try {
        const resp = await client.post(`${provisionHost}/api/${version}/authorize`, authorizeArgs);
        // Write access token to file
        const globalConfig = { accessToken: resp.data.accessToken };
        writeGlobalConfig(globalConfig);
    }
    catch (err) {
        printServerErr(err);
        return await flushAndExit(1, err);
    }
});
//# sourceMappingURL=login.js.map